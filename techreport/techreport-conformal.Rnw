\documentclass[11pt]{article}
%\documentclass[manuscript]{biometrika}
%\documentclass{biometrika}
%\documentclass[lineno]{biometrika}

\usepackage{amscd}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{natbib}
\usepackage{url}
\usepackage{graphicx,times}
\usepackage{epsfig}
\usepackage{mathtools}
\usepackage{xcolor}
%\usepackage{tikz-cd}
%\usepackage{setspace}
%\usepackage{epstopdf}
\usepackage{dsfont} % blackboard numerals

%\epstopdfDeclareGraphicsRule{.gif}{png}{.png}{convert gif:#1 png:\OutputFile}
%\AppendGraphicsExtensions{.gif}

\usepackage{geometry}
\geometry{margin=1in}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Prob}{\mathbb{P}}
\newcommand{\exreal}{\overline{\R}}
\newcommand{\fatdot}{\,\cdot\,}
\newcommand{\Estar}{E^{\textstyle{*}}}
\newcommand{\Holder}{\mathcal{G}}
\newcommand{\Copt}{C^{(\alpha)}}
\newcommand{\Copthat}{\widehat{C}^{(\alpha)}}
\newcommand{\Coptloc}{\widehat{C}^{(\alpha)}_{\text{loc}}}
\newcommand{\Coptglm}{\widehat{C}^{(\alpha)}_{n, k}}
\newcommand{\Coptglmn}{C^{(\alpha)}_{n, k}}
\newcommand{\ptrue}{p_{\beta, \phi}}
\newcommand{\betahat}{\hat{\beta}}
\newcommand{\thetahat}{\hat{\theta}}
\newcommand{\phihat}{\hat{\phi}}
\newcommand{\psihat}{\hat{\psi}}
\newcommand{\phat}{p_{\betahat, \phihat}}
\newcommand{\phatnon}{\hat{p}_{\beta, \phi}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\talpha}{t^{(\alpha)}}
\newcommand{\Aalpha}{A^{(\alpha)}}
\newcommand{\Aaxe}{A^{(\alpha)}_{x,\varepsilon}}
\newcommand{\thatalpha}{\hat{t}^{(\alpha)}}
\newcommand{\ttildealpha}{\tilde{t}^{(\alpha)}}
\newcommand{\tinfk}{t^{(\alpha)}_{\text{inf}, k}}
\newcommand{\tsupk}{t^{(\alpha)}_{\text{sup}, k}}
\newcommand{\rootn}{\sqrt{n}}

\newcommand{\xstar}{x^{\textstyle{*}}}
\newcommand{\zstar}{z^{\textstyle{*}}}
\newcommand{\Astar}{A^{\textstyle{*}}}

%\newcommand{\comment}[1]{\textcolor{red}{[#1]}}
\newcommand{\inner}[1]{\langle #1 \rangle}
\newcommand{\indicator}[1]{\mathds{1}\left\{ #1 \right\}}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\dom}{dom}

\newtheorem{lem}{Lemma} 
\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary} 
\newtheorem{defn}{Definition} 
\newtheorem{prop}{Proposition} 

\allowdisplaybreaks

\title{Technical report for ``Conformal prediction for exponential 
  families and generalized linear models''}
\author{Daniel J. Eck}


\begin{document}

\maketitle

\begin{abstract}
In this supplementary materials document we provide all of the code to 
reproduce the analyses which appear in the paper \citet{eck2019conformal} and 
the R package \citet{eck2018conformalR}.  Several additional analyses are 
provided which illustrate the advantages of conformal prediction regions.  In 
particular, we provide evidence that the parametric conformal prediction 
region, developed in \citet{eck2019conformal}, compares favorably to other 
prediction regions even when the parametric model is misspecified.  
\end{abstract}

\vspace*{0.5cm}

\tableofcontents

\vspace*{0.5cm}

The following R packages are required in order to replicate the calculations 
within this document. 

<<>>=
library(parallel)
library(MASS)
library(statmod)
library(HDInterval)
library(conformal.glm) ## https://github.com/DEck13/conformal.glm
library(conformalInference) ## https://github.com/ryantibs/conformal
library(faraway)
library(geometry)
library(xtable)
library(rgl)
@

We set the error tolerance to be $\alpha = 0.10$ for all prediction regions 
unless otherwise noted.


\section{Introduction/Summary of simulation results}

This manuscript (and corresponding .Rnw file) provides all of the code to 
reproduce the analyses which appear in the paper \citet{eck2019conformal}, the 
README file in the R package \citet{eck2018conformalR}, and this document.  
Several additional analyses to those presented in 
\citet{eck2019conformal} are provided in this document.  
Of particular intherest, we investigate the performance of parametric 
conformal prediction regions under model misspecification.  
Specifically, we focus on settings where the underlying data is generated 
via a Gamma distribution and parametric prediction regions are obtained using a 
cubic regression model assuming homoscedastic normal errors.  The cubic fit is 
chosen because it is intuitive and it fits the Gamma data better than a simple 
linear regression model or a quadratic model.  

Our goal in this manuscript is to demonstrate the advantages and disadvantages 
of our binned and transformation based parametric conformal prediction regions 
\citep{eck2019conformal} 
compared with the nonparametric conformal prediction region 
\citep{lei2014distribution}, the least squares (LS) conformal prediction 
region \citep{lei2018distribution} obtained from conformalized residual scores, 
the least squares locally weighted (LSLW) conformal prediction region 
\citep[Section 5.2]{lei2018distribution} obtained from conformalized locally 
weighted residual scores, and the highest density (HD) region. In analyses 
with model misspecification, the parametric, LS, and LSLW conformal prediction 
regions and HD prediction region are constructed under the misspecified 
model.  The binning used to construct the parametric and 
nonparametric conformal prediction regions follows the bin width asymptotics 
of \citet{lei2014distribution}.

%In our simulations 
We find that the binned parametric conformal prediction 
region performs well even when the model is misspecified.  By construction, 
this region, along with the nonparametric conformal prediction region, 
maintains finite-sample local validity with respect to binning.  
These conformal prediction regions therefore achieves finite-sample marginal 
validity.  The guarantee of finite-sample marginal and local validity are 
noted benefits of these conformal prediction regions 
\citep{lei2014distribution, eck2019conformal}.  
However, the binned parametric and nonparametric conformal prediction 
regions are visually very different, as seen in 
Section~\ref{sec:plotsofregions}, and give different prediction errors at 
small to moderate sample sizes.  We see that the binned parametric conformal 
prediction region adapts naturally to the data when the model is correctly 
specified or modest deviations from the specified model are present.  
On the other hand, the nonparametric conformal prediction region does not 
adapt well to data obtained from a Gamma regression model or data obtained 
from a linear regression model with a steep mean function where steepness is 
relative to the variability about the mean function.

We find that the transformation based parametric conformal prediction region 
performs similarily to the HD prediction region under the assumed model when 
the assumed model is either the data generating model or only modest 
departures exist between the assumed model and the data generating model.  
This parametric conformal prediction region can be prohibitively large and 
inapproriate when the assumed model is in strong disagreement with the data 
generating model.  However, this parametric conformal prediction region 
maintains finite sample marginal coverage in such settings.

The LS conformal prediction region obtains marginal validity 
\citep{lei2018distribution} but performs poorly when deviations about the 
estimated mean function are either not symmetric, not constant, or both.
When heterogeneity is present, the LS conformal prediction region exhibits 
undercoverage in regions where variability about the mean function is large 
and overcoverage in regions where variability about the mean function is 
small.  This conformal prediction region is very sensitive to model 
misspecification.  
The LSLW conformal prediction region also obtains marginal validity 
\citep[Section 5.2]{lei2018distribution} and it is far less sensitive to 
model misspecification than the LS conformal prediction region.  
However, the LSLW conformal prediction region is not appropriate 
when deviations about an estimated mean function are obviously not 
symmetric, as evidenced in Section~\ref{sec:gammaplots}.



\section{Illustrative example from the README file}
\label{sec:README}

We provide a gamma regression example with perfect model specification to 
illustrate the performance of conformal predictions when the model is known 
and the model does not have additive symmetric errors.  We also compare 
conformal prediction regions to the oracle highest density region under 
the correct model. This example is included in the corresponding paper  
\citet{eck2019conformal} and the README file of the corresponding 
R package \texttt{conformal.glm} \citep{eck2018conformalR}.


<<initialfit, cache = TRUE>>=
alpha <- 0.10
n <- 500
shape <- 2
beta <- c(1/4, 2)

set.seed(13)
x <- matrix(runif(n), ncol = 1)
rate <- cbind(1, x) %*% beta * shape
y <- rgamma(n = n, shape = shape, rate = rate)
data.readme <- data.frame(y = y, x = x)
colnames(data.readme)[2] <- c("x1")

fit.readme = glm(y ~ x1, family = Gamma, data = data.readme)
summary(fit.readme)
@


We now compute the binned and transformation based parametric conformal
prediction regions \citep{eck2019conformal} 
and the nonparametric conformal prediction region \citep{lei2014distribution} 
using the \texttt{conformal.glm} function in the \texttt{conformal.glm} package.  
For illustration, we set the number of bins to be equal to 3.  
Since $X_i \sim U(0,1)$, we expect for there to be about 167 cases per bin with 
this choice of 3 bins.  This choice for the number of bins is consistent with 
the bin width asymptotics in \citet{lei2014distribution}.  The number of cores 
is set to 7,  if your computer has fewer than 7 cores at its disposal then you 
have to reduce the number of cores.  This will not effect the final output but 
it will take longer to run. 


<<initialconfit, cache = TRUE>>=
bins <- 3
system.time(cpred <- conformal.glm(fit.readme, 
  nonparametric = TRUE, bins = bins, cores = 7, 
  method = "both"))
parabinCI <- cpred$paraconfbin
nonparabinCI <- cpred$nonparaconfbin
transformCI <- cpred$transformconf
@


We now compute the least squares with local weighting (LSLW) conformal 
prediction region \citep[Section 5.2]{lei2018distribution} using the 
\texttt{conformal.pred} function in the \texttt{conformalInference} package 
\citep{thibshirani2016conformalR}.  
%This LSLW conformal prediction region is constructed with local weighting as 
%in \citet[Section 5.2]{lei2018distribution}.
In this procedure, the residuals from a regression fit are weighted by an 
estimate of the conditional mean absolute deviation (MAD) of 
$(Y - \mu(X))|X=x$, as a function of $x$.  For augmented data including a 
proposed $y$, we let $\hat{\rho}_y(x)$ denote the estimate of the MAD.  
The conformal prediction procedure now uses 
$$
  R_{y,i} = \frac{|Y_i - \hat{\mu}_y(X_i)|}{\hat{\rho}_y(X_i)}, 
    \qquad (i = 1,...,n+1)
$$
as a anti-conformity measure. See Section 5.2 in \citet{lei2018distribution} 
for more details.  The code below implements this method computing residuals 
from a cubic regression model, the cubic model fits the Gamma data better 
than a simple linear or quadratic model.  We estimate $\hat{\rho}_y$ using a 
smoothing spline whose parameters are chosen by cross-validation.  


<<initialLSLWconfit, cache = TRUE>>=
funs <- lm.funs(intercept = TRUE)
train.fun <- funs$train.fun
predict.fun <- funs$predict.fun

cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
    df = df, nknots = 10)
}
mad.predict.fun <- function(out, newx){
  predict(out, newx[, 1])$y
}
system.time(p1.tibs <- conformal.pred(x = cbind(x,x^2,x^3), 
  y = y, x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha))
LSLW = cbind(p1.tibs$lo, p1.tibs$up)
@


We now compute the highest density region using the \texttt{hdi} function in 
the \texttt{HDInterval} package \citep{meredith2018HDIntervalR}.


<<initialHDfit, cache = TRUE>>=
betaMLE <- coefficients(fit.readme)
shapeMLE <- as.numeric(gamma.shape(fit.readme)[1])
rateMLE <- cbind(1, x) %*% betaMLE * shapeMLE
HDCI <- do.call(rbind, 
  lapply(1:nrow(x), function(j){ 
    hdi(qgamma, 0.90, shape = shapeMLE, rate = rateMLE[j, 1])
  }))
@


The four prediction regions for this data are depicted below.  The top row 
depicts the parametric conformal prediction region (left panel) and the 
nonparametric conformal prediction region (right panel).  The bin width was 
specified as 1/3 for these conformal prediction regions.  The bottom row 
depicts the least squares conformal prediction region (left panel) and the 
highest density region (right panel).  We see that the parametric conformal 
prediction region is a close discretization of the highest density region, the 
nonparametric conformal prediction region is quite jagged and unnatural, and 
the least squares conformal prediction region exhibits undercoverage for small 
$x$, exhibits overcoverage for large $x$, and includes negative response 
values of large magnitude. 


%\newpage
\begin{figure}[h!]
\begin{center}
<<gammasimexample, echo = FALSE>>=
par(mfrow = c(2,2), oma = c(4,4,0,0), mar = c(1,1,1,1))

# transformation conformal prediction region
ix <- sort(x, index.return = TRUE)$ix
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y), max(y)))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], transformCI[ix, 1], type = "l", col = "red")
lines(x[ix], transformCI[ix, 2], type = "l", col = "red")
axis(2)

# parametric conformal prediction region
ix <- sort(x, index.return = TRUE)$ix
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y), max(y)))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], parabinCI[ix, 1], type = "l", col = "red")
lines(x[ix], parabinCI[ix, 2], type = "l", col = "red")

# nonparametric conformal prediction region
plot.nonparametric <- function(region, x, y, bins){
  if(class(region) != "list"){ 
    stop("Only appropriate for nonparametric conformal prediction region")
  }
  plot.new()
  plot.window(xlim = c(0,1), ylim = c(min(y), max(y)))
  points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
  for(i in 1:bins){ 
    nonpar.i  <- nonparabinCI[[i]]
    odd <- which(1:length(nonpar.i) %% 2 == 1) 
    even <- which(1:length(nonpar.i) %% 2 == 0)
    segments(x0 = 1/bins * (i-1), y0 = nonpar.i, x1 =1/bins * i, 
      col = "red")
    if(i != 1){ 
      nonpar.i.previous <- nonparabinCI[[i-1]]
      nonpar <- sort(c(nonpar.i, nonpar.i.previous))
      odd2 <- which(1:length(nonpar) %% 2 == 1) 
      even2 <- which(1:length(nonpar) %% 2 == 0)
      segments(x0 = 1/bins * (i-1), y0 = nonpar[odd2], 
        y1 = nonpar[even2], col = "red")
    }
  }
}    
plot.nonparametric(nonparabinCI, x = x, y = y, bins = bins)
axis(1); axis(2)

# least squares conformal prediction region
plot.new()
plot.window(xlim = c(0,1), ylim = c(0,max(y)))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLW[ix, 1], type = "l", col = "red")
lines(x[ix], LSLW[ix, 2], type = "l", col = "red")
axis(1)

# axis labels
mtext("x", side = 1, line = 2.5, outer = TRUE, cex = 1.25)
mtext("y", side = 2, line = 2.5, outer = TRUE, cex = 1.25)
@
\end{center}
\caption{Sim setting: $n = 500$, shape = $2$, bins = $3$. 
  The regions are depicted as follows: 
    transformation based parametric conformal prediction (top-left panel),
    binned parametric conformal prediction region (top-right panel),
    nonparametric conformal prediction region (bottom-left panel), and 
    LSLW conformal prediction region (bottom-right panel).}
\label{Fig:plots}
\end{figure}

In Figure~\ref{Fig:plots2} we see that the transformation parametric conformal 
prediction region closely resembles the HD prediction region, and that the 
binned parametric conformal prediction region is a close descretization of 
the HD prediction region.


\begin{figure}[h!]
\begin{center}
<<gammasimexample2, echo = FALSE>>=
par(mfrow = c(1,1), oma = c(4,4,0,0), mar = c(1,1,1,1))
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y), max(y)))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], transformCI[ix, 1], type = "l", lwd = 2, col = "red")
lines(x[ix], transformCI[ix, 2], type = "l", lwd = 2, col = "red")
lines(x[ix], parabinCI[ix, 1], type = "l", lwd = 2, lty = 2, col = "blue")
lines(x[ix], parabinCI[ix, 2], type = "l", lwd = 2, lty = 2, col = "blue")
lines(x[ix], HDCI[ix, 1], type = "l", lwd = 2, lty = 3, col = "black")
lines(x[ix], HDCI[ix, 2], type = "l", lwd = 2, lty = 3, col = "black")
axis(1); axis(2)
legend(0.45, 12.5, legend=c("transformation conformal", 
  "binned parametric conformal", "HD region"), 
  col=c("red", "blue", "black"), cex = 1, lwd = c(2, 2, 2),
  lty=c(1, 2, 3), bty = "n")
@
\end{center}
\label{Fig:plots2}
\end{figure}


All of the presented prediction regions exhibit close to finite-sample 
marginal validity and local validity with respect to binning.  However, 
the transformation conformal prediction region, LSLW conformal prediction 
region, and the HD prediction region do not exhibit finite-sample local 
validity in the second bin and the HD prediction region does not quite 
possess finite-sample marginal validity.  
The binned parametric conformal prediction region is smallest in size 
with an estimated area of 2.19.  The HD prediction region is a close second 
with an estimated area of 2.21.  The tranformation conformal prediction 
region is a respectable third with an estimated area of 2.26.
LSLW conformal prediction region has an estimated area of 2.56 and 
The nonparametric conformal prediction region has an estimated area of 2.68. 
Under correct model specification, the parametric conformal prediction 
regions are similar in performance to that of the highest density prediction 
region.



<<>>=
#########################################
## area and coverage

# nonparametric conformal prediction region
# estimated area
area.nonparametric <- function(region){
  if(class(region) != "list"){ 
    stop("Only appropriate for nonparametric conformal prediction region")
  }
  bins <- length(region); wn <- 1 / bins
  area <- 0
  for(i in 1:bins){
    nonpar.region <- region[[i]]
    area <- area + wn * as.numeric(rep(c(-1,1), 
      length(nonpar.region)/2) %*% nonpar.region)
  }
  area
}
# estimated area of prediction regions
area <- c(
  mean(apply(transformCI, 1, diff)),
  mean(apply(parabinCI, 1, diff)),
  area.nonparametric(nonparabinCI),
  mean(apply(LSLW, 1, diff)),
  mean(apply(HDCI, 1, diff))
)

# marginal local coverage of prediction regions
p <- 1
marginalcov <- c(
  local.coverage(region = transformCI, data = data.readme, d = p, 
    bins = 1, at.data = "TRUE"),
  local.coverage(region = parabinCI, data = data.readme, d = p, 
    bins = 1, at.data = "TRUE"),
  local.coverage(region = nonparabinCI, data = data.readme, d = p, 
    nonparametric = "TRUE", bins = 1, at.data = "TRUE"),
  local.coverage(region = LSLW, data = data.readme, d = p, 
    bins = 1, at.data = "TRUE"), 
  local.coverage(region = HDCI, data = data.readme, d = p, 
    bins = 1, at.data = "TRUE")
)

# local coverage of prediction regions
localcov <- cbind(
  local.coverage(region = transformCI, data = data.readme, d = p, 
    bins = bins, at.data = "TRUE"),
  local.coverage(region = parabinCI, data = data.readme, d = p, 
    bins = bins, at.data = "TRUE"),
  local.coverage(region = nonparabinCI, data = data.readme, d = p, 
    nonparametric = "TRUE", bins = bins, at.data = "TRUE"),
  local.coverage(region = LSLW, data = data.readme, d = p, 
    bins = bins, at.data = "TRUE"),
  local.coverage(region = HDCI, data = data.readme, d = p, 
    bins = bins, at.data = "TRUE")
)

# diagnostics
diagnostics <- rbind(area, marginalcov, localcov)
colnames(diagnostics) <- c("transformCI", "binparaCI",  
  "binnonparaCI", "LSLW", "HDCI")
rownames(diagnostics) <- c("area", "marginal coverage", "bin 1 coverage", 
  "bin 2 coverage", "bin 3 coverage")
@


<<tabdiagnostics, results = 'asis'>>=
xtable(diagnostics, digits = c(0, 2, 2, 2, 2, 2))
@


\section{Extension of the illustrative example from the README file}

In this extension we investigate the local coverage properties of six  
prediction regions, the five from the previous section and a least squares 
(LS) conformal prediction region without local weighting.  Local coverage is 
assessed via a Monte Carlo simulation of size $B = 50$.  At each iteration 
of this simulation a new dataset is generated under the same specifications 
as those in the README file.  We then compute the local coverage probabilities 
with respect to each bin and also approximate conditional coverage across $x$.  
We do not assess coverage properties directly at $x$ for all $x \in (0,1]$.  
This corresponds to the notion of conditional validity which cannot be 
achieved in tandem with an oracle estimation in finite sample settings when 
distributions are continuous \citep[Section 2.2]{lei2014distribution}.  
What we do instead is we assess local coverage with a binning in $x$ that is 
much finer than the binning that was used to create the misspecified 
parametric and nonparametric conformal prediction regions.  We form 25 bins 
of length 0.04. 



\subsection{Diagnostic measures}

Several diagnostic measures are used to compare conformal prediction regions.
These diagnostic measures compare prediction regions by their 
prediction error, volume, and coverage properties.
Our prediction error diagnostic metric will be an average of the squared 
distances of observations outside of the prediction region to the closest 
boundary of the prediction region, averaged over all 
observations. An observation that falls within the prediction region 
has an error of 0.  More formally this prediction error metric is 
$$
  \text{prediction error} 
    = n^{-1}\sum_{i=1}^n\indicator{Y_i \not\in \Copt(X_i)}
      \left(\min_{j=1,\ldots,m_i}\left\{\min\{|Y_i - a_{i,j}|, 
        |Y_i - b_{i,j}|\}\right\}\right)^2,
$$
where $a_{i,j}$ and $b_{i,j}$ are, respectively, the lower and upper 
boundaries of possible $j = 1, \ldots, m_i$ disjoint intervals forming 
the prediction region.  

The volume of each prediction region will be estimated by the average of the 
upper boundary minus the lower boundary across observed $\X$, written as
$$ 
  \text{area} = n^{-1}\sum_{i=1}^n\sum_{j=1}^{m_i}(b_{i,j} - a_{i,j}).
$$
%This estimate of area is appropriate in our simulations in which realizations 
%of the predictors are generated as $X \sim U(0,1)$.   

%The area of each prediction region will be estimated by the average of the 
%upper boundary minus the lower boundary across observed $\X$, written as
%$$ 
%  \text{area} = n^{-1}\sum_{i=1}^n\sum_{j=1}^{m_i}(b_{i,j} - a_{i,j}).
%$$
%This estimate of area is appropriate in our simulations in which realiztions 
%of the predictors are generated as $X \sim U(0,1)$.   

To assess finite-sample marginal validity we calculate the proportion of 
responses that fall within the prediction region.  To assess finite-sample 
local validity with respect to binning we first bin the predictor data and 
then, for each bin, we calculate the proportion of responses that fall 
within the prediciton region. The same procedure is used to assess 
finite-sample conditional validity, but we use a much finer binning regime 
than what was used to assess finite-sample local validity.  

The following function computes our estimate of prediction error at the 
observed data when the prediction region is not the nonparametric 
conformal prediction region.

<<>>=
absolute.error <- function(y, region, squared = TRUE){
  lwr <- region[, 1]
  upr <- region[, 2]
  index <- which(!(lwr <= y & y <= upr))
  out <- sum(unlist(lapply(index, function(j){
    error <- NULL
    if(squared == FALSE) error <- 
      min(abs(y[j] - lwr[j]), abs(y[j] - upr[j]))
    if(squared == TRUE) error <- 
      (min(abs(y[j] - lwr[j]), abs(y[j] - upr[j])))^2
    error
  }))) / length(y)
  out
}
@

The following function computes our estimate of prediction error at the 
observed data when the prediction region is the nonparametric conformal 
prediction region.

<<>>=
absolute.error.nonparametric <- function(data, region, 
  squared = TRUE){
  n <- nrow(data)
  n.bins.region <- length(region)
  d <- ncol(data) - 1
  x <- as.matrix(data[,1:d + 1], col = d)
  index.bins.region <- find.index(x, wn = 1/n.bins.region, d = d)
  y <- data[, 1]
  area <- 0
  for(j in 1:n){
    index.j <- which(index.bins.region == j)
    error <- c(y[j] - region[[index.bins.region[j]]])
    index <- 0
    if(any(error > 0)) index <- max(which(error > 0))
    if(index %% 2 == 0){
      if(squared == FALSE) area <- 
        area + min(abs(error)) / n
      if(squared == TRUE) area <- 
        area + min(abs(error))^2 / n
    }    
  }
  area
}
@

Our Monte Carlo simulator follows. This function computes all of the 
dignostics and local coverage probabilities for each prediction region 
for every generated dataset.


\begin{center}
{\Huge Revised up to here}
\end{center}


<<>>=
dat <- data.frame(y = y, x1 = x)
gamma_simulator <- function(beta, n = 500, alpha = 0.10, bins = 3, 
  family = "Gamma", link = "inverse", shape = 2, 
  parametric = TRUE, nonparametric = TRUE, method = "both", 
  LS = TRUE, LSLW = TRUE, HD = TRUE, cores = 7){

  ## in this univariate problem, p and d are the same
  p <- d <- length(beta) - 1
  x <- matrix(runif(n*p), ncol = p)
  y <- rep(0,n)
  dat <- data.frame(y = y, x = x)
  colnames(dat)[2:(p+1)] <- paste("x", 1:p, sep = "")

  ## set up partition
  if(class(bins) == "NULL"){
    wn <- min(1/ floor(1 / (log(n)/n)^(1/(d+3))), 1/2)
    bins <- 1 / wn
  }

  ## generate the data (has functionality for different 
  ## families and link functions)
  if(family == "Gamma"){
    if(link == "identity"){
      rate <- (1 / (cbind(1, x) %*% beta)) * shape
      y <- rgamma(n = n, shape = shape, rate = rate)
      dat$y <- y / sd(y)
    }
    if(link == "inverse"){
      rate <- (cbind(1, x) %*% beta) * shape
      y <- rgamma(n = n, shape = shape, rate = rate)
      dat$y <- y / sd(y)
    }
    if(link == "log"){
      rate <- (1 / exp(cbind(1, x) %*% beta)) * shape
      y <- rgamma(n = n, shape = shape, rate = rate)
      dat$y <- y / sd(y)
    }
  }
  if(family == "gaussian"){
    mu <- cbind(1, x) %*% beta
    y <- rnorm(n = n, mean = mu, sd = sd)
    dat$y <- y / sd(y)
  }
  if(family == "inverse.gaussian"){
    mu = 1 / sqrt(cbind(1, x) %*% beta)
    y <- rinvgauss(n = n, mean = mu)
    dat$y <- y / sd(y)
  }

  ## fit the Gamma regression model
  fit <- glm(y ~ x1, family = "Gamma", data = dat)
  parabinCI <- transformCI <- nonparabinCI <- LSCI <- 
    LSLWCI <- HDCI <- NULL
  formula <- fit$formula
  newdata <- dat
  respname <- all.vars(formula)[1]
  newdata <- newdata[, !(colnames(dat) %in% respname)]
  newdata <- as.matrix(newdata)

  ## obtain the prediction regions
  output.parabin <- output.transform <- output.nonparabin <- 
    output.LS <- output.LSLW <- output.HD <- rep(NA, bins + 1)  
  if(parametric){ 
    cpred <- conformal.glm(fit, parametric = TRUE, 
      nonparametric = FALSE, alpha = alpha, method = "both", 
      bins = bins, cores = cores, newdata = newdata, 
      precision = 0.02)   

    # bin parametric conformal
    parabinCI <- cpred$paraconfbin
    marginal.parabin <- local.coverage(region = parabinCI, 
      data = dat, d = p, bins = 1, at.data = "TRUE")  
    local.parabin <- local.coverage(region = parabinCI, 
      data = dat, d = p, bins = bins, at.data = "TRUE")
    local.inx.parabin <- local.coverage(region = parabinCI, 
      data = dat, d = p, bins = 25, at.data = "TRUE")
    output.parabin <- c(marginal.parabin, local.parabin, 
      local.inx.parabin, 
      mean(apply(parabinCI, 1, diff)), 
      absolute.error(y = y, region = parabinCI))

    # transform parametric conformal
    transformCI <- cpred$transformconf      
    marginal.transform <- local.coverage(region = transformCI, 
      data = dat, d = p, bins = 1, at.data = "TRUE")  
    local.transform <- local.coverage(region = transformCI, 
      data = dat, d = p, bins = bins, at.data = "TRUE")
    local.inx.transform <- local.coverage(region = transformCI, 
      data = dat, d = p, bins = 25, at.data = "TRUE")
    output.transform <- c(marginal.transform, local.transform, 
      local.inx.transform, 
      mean(apply(transformCI, 1, diff)), 
      absolute.error(y = y, region = transformCI))      
  }
  if(nonparametric){ 
    cpred <- conformal.glm(fit, parametric = FALSE, 
      nonparametric = TRUE, alpha = alpha, method = "both", 
      bins = bins, cores = cores, precision = 0.02)
    nonparabinCI <- cpred$nonparaconfbin

    marginal.nonparabin <- local.coverage(region = nonparabinCI, 
      nonparametric = "TRUE", data = dat, d = p, bins = 1, 
      at.data = "TRUE")
    local.nonparabin <- local.coverage(region = nonparabinCI, 
      nonparametric = "TRUE", data = dat, d = p, bins = bins, 
      at.data = "TRUE")
    local.inx.nonparabin <- local.coverage(region = nonparabinCI, 
      nonparametric = "TRUE", data = dat, d = p, bins = 25, 
      at.data = "TRUE")
    output.nonparabin <- 
      c(marginal.nonparabin, local.nonparabin, 
        local.inx.nonparabin, 
        area.nonparametric(nonparabinCI),
        absolute.error.nonparametric(data = dat, 
          region = nonparabinCI))    
  }      
  if(LS){
    p1.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
      x0 = cbind(x,x^2,x^3), 
      train.fun = train.fun, predict.fun = predict.fun, 
      alpha = alpha)
    LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

    marginal.LS <- local.coverage(region = LSCI, 
      data = dat, d = p, bins = 1, at.data = "TRUE")
    local.LS <- local.coverage(region = LSCI, 
      data = dat, d = p, bins = bins, at.data = "TRUE")
    local.inx.LS <- local.coverage(region = LSCI, 
      data = dat, d = p, bins = 25, at.data = "TRUE")
    output.LS <- c(marginal.LS, local.LS, local.inx.LS, 
      mean(apply(LSCI, 1, diff)), 
      absolute.error(y = y, region = LSCI))
  }
  if(LSLW){
    cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
    abs.resid <- abs(cubic.model$resid)
    smooth.call <- smooth.spline(x, abs.resid, 
      nknots = 10)
    lambda <- smooth.call$lambda
    df <- smooth.call$df
    mad.train.fun <- function(x, y, out = NULL){
      smooth.spline(x[, 1], y, lambda = lambda, 
      df = df, nknots = 10)
    }
    p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
      x0 = cbind(x,x^2,x^3), 
      train.fun = train.fun, predict.fun = predict.fun, 
      mad.train.fun = mad.train.fun,
      mad.predict.fun = mad.predict.fun,
      alpha = alpha)
    LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)

    marginal.LSLW <- local.coverage(region = LSLWCI, 
      data = dat, d = p, bins = 1, at.data = "TRUE")
    local.LSLW <- local.coverage(region = LSLWCI, 
      data = dat, d = p, bins = bins, at.data = "TRUE")
    local.inx.LSLW <- local.coverage(region = LSLWCI, 
      data = dat, d = p, bins = 25, at.data = "TRUE")
    output.LSLW <- c(marginal.LSLW, local.LSLW, local.inx.LSLW, 
      mean(apply(LSLWCI, 1, diff)), 
      absolute.error(y = y, region = LSLWCI))          
  }
  if(HD){
    betaMLE <- coefficients(fit)
    shapeMLE <- as.numeric(gamma.shape(fit)[1])
    rateMLE <- cbind(1, newdata) %*% betaMLE * shapeMLE
    HDCI <- do.call(rbind, lapply(1:nrow(newdata), function(j){ 
      hdi(qgamma, 1 - alpha, shape = shapeMLE, rate = rateMLE[j, 1])
    }))

    marginal.HD <- local.coverage(region = HDCI, 
      data = dat, d = p, bins = 1, at.data = "TRUE")
    local.HD <- local.coverage(region = HDCI, 
      data = dat, d = p, bins = bins, at.data = "TRUE")
    local.inx.HD <- local.coverage(region = HDCI, 
      data = dat, d = p, bins = 25, at.data = "TRUE")
    output.HD <- c(marginal.HD, local.HD, local.inx.HD, 
      mean(apply(HDCI, 1, diff)), 
      absolute.error(y = y, region = HDCI))
  }
    
  output <- list(output.parabin = output.parabin, 
    output.transform = output.transform, 
    output.nonparabin = output.nonparabin,
    output.LS = output.LS, 
    output.LSLW = output.LSLW, 
    output.HD = output.HD)
  output
}
@

The following performs our Monte Carlo simulation with $B = 50$ iterations. 

<<localcoverage, cache = TRUE>>=
set.seed(13)
B <- 50
system.time(local.500.3.2 <- do.call(cbind, lapply(1:B, 
  FUN = function(j){
    unlist(gamma_simulator(beta = beta))
})))
@

<<>>=
local.gamma.500.3.2 <- cbind( 
  rowMeans(local.500.3.2, na.rm = TRUE),  
  apply(local.500.3.2, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))

options(scipen = 999)
local.gamma.500.3.2[, 1] <- round(local.gamma.500.3.2[, 1], 3)
local.gamma.500.3.2[, 2] <- round(local.gamma.500.3.2[, 2], 4)
@


%Describe the table
Diagnostics for each of the siz prediction regions are given in Table 1 and 
Figure~\ref{Fig:coverageinx500.3}.  We see that the parametric 
conformal prediction region performs as advertised.  When the model is 
correctly specified, the parametric conformal prediction region is similar to 
the minimum length HD prediction region in area and prediction error (and in 
appearance as seen in Figure~\ref{Fig:plots}).  The parametric conformal 
prediction region exhibits some conservative overcoverage marginally and with 
respect to binning, and some undercoverage in $x$ for values close to the 
break points of the bins.  The LSLW conformal prediction region has lower 
prediction error than the parametric conformal prediction error but such a 
benefit comes with the cost of lack of precision (increase in size) and 
dramatic overcoverage.  The low prediction error of the LSLW conformal 
prediction region appears to stem from its ability to be far wider than 
the other prediction intervals at the values of $x$ where the response data 
is most variable, as seen in Figure~\ref{Fig:plots}.  This feature combined 
with its symmetric errors construction is what leads to its increase in size.  
The LSLW conformal prediction region is seen to provide conservative 
finite-sample local coverage in $x$.
The nonparametric and LS conformal prediction regions are larger and have 
larger prediction error than the parametric conformal prediction region.  
The LS conformal prediction exhibits large undercoverage when the predictor 
is small and large overcoverage when the predictor is large.  This is best 
evidenced by Figure~\ref{Fig:coverageinx500.3}.



\begin{table}[t!]
\tiny
\begin{center}
\begin{tabular}{lcccccc}
  & Parametric & Transformation & Nonparametric & LS        & LSLW      & HD     \\  
  & Conformal  & Conformal      & Conformal     & Conformal & Conformal & Region \\
    marginal coverage & 
  $\Sexpr{local.gamma.500.3.2[1, 1]} \; (\Sexpr{local.gamma.500.3.2[1, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[32, 1]} \; (\Sexpr{local.gamma.500.3.2[32, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[63, 1]} \; (\Sexpr{local.gamma.500.3.2[63, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[94, 1]} \; (\Sexpr{local.gamma.500.3.2[94, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[125, 1]} \; (\Sexpr{local.gamma.500.3.2[125, 2]})$ &
  $\Sexpr{local.gamma.500.3.2[156, 1]} \; (\Sexpr{local.gamma.500.3.2[156, 2]})$ \\ 
    local coverage when $0 < x < 1/3$ & 
  $\Sexpr{local.gamma.500.3.2[2, 1]} \; (\Sexpr{local.gamma.500.3.2[2, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[33, 1]} \; (\Sexpr{local.gamma.500.3.2[33, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[64, 1]} \; (\Sexpr{local.gamma.500.3.2[64, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[95, 1]} \; (\Sexpr{local.gamma.500.3.2[95, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[126, 1]} \; (\Sexpr{local.gamma.500.3.2[126, 2]})$ &
  $\Sexpr{local.gamma.500.3.2[157, 1]} \; (\Sexpr{local.gamma.500.3.2[157, 2]})$ \\
    local coverage when $1/3 \leq x < 2/3$ & 
  $\Sexpr{local.gamma.500.3.2[3, 1]} \; (\Sexpr{local.gamma.500.3.2[3, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[34, 1]} \; (\Sexpr{local.gamma.500.3.2[34, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[65, 1]} \; (\Sexpr{local.gamma.500.3.2[65, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[96, 1]} \; (\Sexpr{local.gamma.500.3.2[96, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[127, 1]} \; (\Sexpr{local.gamma.500.3.2[127, 2]})$ &
  $\Sexpr{local.gamma.500.3.2[158, 1]} \; (\Sexpr{local.gamma.500.3.2[158, 2]})$ \\
    local coverage when $2/3 \leq x < 1$ & 
  $\Sexpr{local.gamma.500.3.2[4, 1]} \; (\Sexpr{local.gamma.500.3.2[4, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[35, 1]} \; (\Sexpr{local.gamma.500.3.2[35, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[66, 1]} \; (\Sexpr{local.gamma.500.3.2[66, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[97, 1]} \; (\Sexpr{local.gamma.500.3.2[97, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[128, 1]} \; (\Sexpr{local.gamma.500.3.2[128, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[159, 1]} \; (\Sexpr{local.gamma.500.3.2[159, 2]})$ \\
    area & 
  $\Sexpr{local.gamma.500.3.2[30, 1]} \; (\Sexpr{local.gamma.500.3.2[30, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[61, 1]} \; (\Sexpr{local.gamma.500.3.2[61, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[92, 1]} \; (\Sexpr{local.gamma.500.3.2[92, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[123, 1]} \; (\Sexpr{local.gamma.500.3.2[123, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[154, 1]} \; (\Sexpr{local.gamma.500.3.2[154, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[185, 1]} \; (\Sexpr{local.gamma.500.3.2[185, 2]})$ \\
    prediction error & 
  $\Sexpr{local.gamma.500.3.2[31, 1]} \; (\Sexpr{local.gamma.500.3.2[31, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[62, 1]} \; (\Sexpr{local.gamma.500.3.2[62, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[93, 1]} \; (\Sexpr{local.gamma.500.3.2[93, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[124, 1]} \; (\Sexpr{local.gamma.500.3.2[124, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[155, 1]} \; (\Sexpr{local.gamma.500.3.2[155, 2]})$ & 
  $\Sexpr{local.gamma.500.3.2[186, 1]} \; (\Sexpr{local.gamma.500.3.2[186, 2]})$ 
\end{tabular}
\end{center}
\caption{Diagnostics of prediction regions. This table gives 
    the area, prediction error, marginal coverage, and local coverages with 
    respect to our binning scheme for the parametric, transformation, 
    nonparametric, LS, and LSLW conformal prediction regions and the HD 
    prediction region.}
\label{Tab:gamma-results}
\end{table}





\begin{figure}[h!]
\begin{center}
<<readme-inx, echo = FALSE, fig.height = 4, fig.width = 4>>=
par(mfrow = c(1,1), oma = c(4,4,0,0), mar = c(1,1,1,1))

inx <- 0.02 + 0:24 * 0.04
para.local.coverage.inx <- local.gamma.500.3.2[5:29, 1]
transform.local.coverage.inx <- local.gamma.500.3.2[36:60, 1]
nonpara.local.coverage.inx <- local.gamma.500.3.2[67:91, 1]
LS.local.coverage.inx <- local.gamma.500.3.2[98:122, 1]
LSLW.local.coverage.inx <- local.gamma.500.3.2[129:153, 1]
HD.local.coverage.inx <- local.gamma.500.3.2[160:184, 1]

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.40, 1.00))
lines(inx, para.local.coverage.inx, col = "red", lty = 1)
lines(inx, transform.local.coverage.inx, col = "red", lty = 2)
lines(inx, nonpara.local.coverage.inx, col = "green", lty = 2)
lines(inx, LSLW.local.coverage.inx, col = "purple", lty = 1)
lines(inx, LS.local.coverage.inx, col = "black", lty = 2)
lines(inx, HD.local.coverage.inx, col = "blue", lty = 4)
abline(h = 0.90, lty = 1, col = "grey")
axis(1); axis(2)
mtext("x", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("coverage probability", side = 2, cex = 1.25, line = 2, outer = TRUE)

legend(0.20, 0.75, legend=c("parametric", "transform", 
  "nonparametric", "LSLW", "LS", 
  "HD", "nominal coverage"), col=c("red", "red", "green", "purple", 
  "black", "blue", "grey"), cex = 1, 
  lty=c(1,2,2,1,2,4,1), bty = "n")
@
\end{center}
\caption{Plot of the estimated coverage probabilities of prediction regions 
  across $x$.}
\label{Fig:coverageinx500.3}
\end{figure}




\newpage
\section{Predicting the risk of diabetes}
\label{sec:diabetes}

In this Section we reproduce the data analysis that appears in Section 6 of 
\citet{eck2019conformal}.  
We examine the influence of several variables on blood sugar, or glycosylated 
hemoglobin percentage (also known as HbA1c), an important risk factor for 
diabetes.  A glycosylated hemoglobin value of 6.5\% can be used as a cutoff 
for positive diagnosis of diabetes \citep{world2011use}. 

We predict an individual's glycosylated hemoglobin from their height, 
weight, age, and gender, all of which are easy to measure, inexpensive, and do 
not require any laboratory testing.  
The data in this analysis come from a population-based sample of 403 rural 
African-Americans in Virginia \citep{willems1997prevalence}, taken from the 
\texttt{faraway} R package \citep{faraway2016R}.  
We considered a gamma regression model that only includes linear terms for 
each covariate, a linear regression model with homoskedastic normal errors 
and the same linear terms for each covariate, and a linear regression model 
with homoskedastic normal errors that also included quadratic terms for 
each covariate.
Of these considered the models, the gamma regression model fit the data 
best on the basis that it had the lowest AIC value and it gave the best 
predictive predictive performance on the basis that it had the lowest 
sum of squares prediction error.  
That being said, we do not know the data generating process.

Based on these covariates, conformal prediction regions provide finite sample 
valid prediction regions for glycosylated hemoglobin that may be useful for 
diagnosing diabetes in this study population.
The data set is loaded from the R package \citet{faraway2016R}.

<<>>=
data(diabetes)
@

We throw away data points that contain missing values of any variable of 
interest.

<<>>=
dat <- diabetes[, c("glyhb", "height", "weight", "age", "gender")]
dat <- dat[complete.cases(dat), ]
@


The Gamma regression model with with log link function is selected among 
several candidate models as the model used for inference in this analysis.
This model has the lowest AIC value among candidates.


<<>>=
m.gamma.log <- glm(glyhb ~ height + weight + age + gender, 
  data = dat, family = Gamma(link = log))
m.gamma <- glm(glyhb ~ height + weight + age + gender, 
  data = dat, family = "Gamma")
m.gamma.identity <- glm(glyhb ~ height + weight + age + gender, 
  data = dat, family = Gamma(link = identity))
m.gaussian <- glm(glyhb ~ height + weight + age + gender, 
  data = dat, family = "gaussian", x = TRUE)
X <- m.gaussian$x
m.gaussian.2 <- glm(glyhb ~ height + weight + age + I(height^2) 
  + I(weight^2) + I(age^2) + gender, 
  data = dat, family = "gaussian", x = TRUE)

AIC(m.gamma.log, m.gamma, m.gamma.identity, m.gaussian, m.gaussian.2)
@


This model also provides satisfactory prediction as seen in 
Figure~\ref{diabetes:diagnostics}.


\begin{figure}
\begin{center}
<<echo = FALSE, fig.height = 3>>=
par(mfrow = c(1,3))
preds <- predict(m.gamma.log, type = "response")
plot(residuals(m.gamma.log, "pearson") ~ preds, 
  xlab = "predicted response", ylab = "Pearson residuals", 
  main = "Gamma (log link)", pch = 19, 
  col = rgb(0,0,0,alpha=0.2))
abline(h = 0, col = "red", lty = 3, lwd = 2)

preds <- predict(m.gaussian, type = "response")
plot(residuals(m.gaussian, "pearson") ~ preds, 
  xlab = "predicted response", ylab = "", 
  main = "linear regression", pch = 19, 
  col = rgb(0,0,0,alpha=0.2))
abline(h = 0, col = "red", lty = 3, lwd = 2)

preds <- predict(m.gaussian.2, type = "response")
plot(residuals(m.gaussian.2, "pearson") ~ preds, 
  xlab = "predicted response", main = "quadratic regression",  
  ylab = "", pch = 19, col = rgb(0,0,0,alpha=0.2))
abline(h = 0, col = "red", lty = 3, lwd = 2)
@
\end{center}
\caption{Predictive performance of candidate models.}
\label{diabetes:diagnostics}
\end{figure}


Six conformal prediction regions are considered for predicting glycosylated 
hemoglobin percentage.  These conformal prediction regions are the binned and 
transformation parametric conformal prediction region with a Gamma model fit, 
the binned and transformation parametric conformal prediction region with a 
Gaussian model fit, the least squares conformal prediction region, 
and the least square conformal prediction region with local weighting.  
All conformal prediction regions correspond to models that only include 
linear terms for each of the covariates.  
The binned Gamma and Gaussian parametric conformal prediction regions were 
computed with binning across the binary gender factor variable, the predictor 
space is partitioned across genders. 
However, no additional binning structure within the levels of gender was 
employed.  


These conformal prediction regions are now constructed.


<<diabetes.conformal, cache = TRUE>>=
## Gamma conformal
system.time(conformal.gamma <- 
  conformal.glm(m.gamma.log, cores = 6, bins = 1, 
    method = "both"))
gamma.paraconfbin <- conformal.gamma$paraconfbin
gamma.transform <- conformal.gamma$transformconf
head(gamma.paraconfbin)
head(gamma.transform)

## Gaussian conformal
system.time(conformal.gaussian <- 
  conformal.glm(m.gaussian, cores = 6, bins = 1, 
    method = "both"))
gaussian.paraconfbin <- conformal.gaussian$paraconfbin
gaussian.transform <- conformal.gaussian$transformconf
head(gaussian.paraconfbin)
head(gaussian.transform)

## LS conformal
funs <- lm.funs(intercept = TRUE)
train.fun <- funs$train.fun
predict.fun <- funs$predict.fun
alpha <- 0.10
y <- dat$glyhb
system.time(p1.tibs <- conformal.pred(x = X[, -1], 
  y = y, x0 = X[, -1], 
  train.fun = train.fun, predict.fun = predict.fun, 
  alpha = alpha))
LS = cbind(p1.tibs$lo, p1.tibs$up)
colnames(LS) <- c("lwr", "upr")
head(LS)

## LSLW conformal
mad.train.fun <- function(x, y, out = NULL){
  lm(y ~ x[, -1], x = TRUE, y = TRUE)
}
mad.predict.fun <- function(out, newx){
  predict(out, as.data.frame(newx))
}
system.time(p2.tibs <- conformal.pred(x = X[, -1], 
  y = y, x0 = X[, -1], 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha))
LSLW = cbind(p2.tibs$lo, p2.tibs$up)
colnames(LSLW) <- c("lwr", "upr")
head(LSLW)
@


We also consider the highest density prediction region under the Gamma 
model, this region is constructed below.

<<>>=
## HD region
library(HDInterval)
betaMLE <- coefficients(m.gamma.log)
shapeMLE <- as.numeric(gamma.shape(m.gamma.log)[1])
rateMLE <- (1 / exp(X %*% betaMLE)) * shapeMLE
#rateMLE <- cbind(1, x) %*% betaMLE * shapeMLE
HD <- do.call(rbind, 
  lapply(1:nrow(X), function(j){ 
    hdi(qgamma, 0.90, shape = shapeMLE, rate = rateMLE[j, 1])
  }))
colnames(HD) <- c("lwr", "upr")
head(HD)
@



\subsection{Results in \citet{eck2019conformal}}

Diagnostics from the six conformal prediction regions are depicted in 
Table 2 of the manuscript \citet{eck2019conformal}.  The error tolerance 
for all prediction regions was set at $\alpha = 0.10$.  We see that 
parametric conformal prediction regions maintain their advertised finite 
sample marginal validity for the predictions of glycosylated hemoglobin.  
These prediction regions provide a balance between marginal coverage, size, 
prediction error, and average conditional coverage (the average of the 
coverage probabilities taken over small subregions of the predictor space).  
The transformation Gamma conformal prediction region balances these criteria 
particularly nicely. This prediction region is relatively small, has relatively 
small prediction error, and it gives near nominal desired coverage.  This 
finding is expected when the underlying estimated density used as the 
parametric conformity measure is a good approximation of the data generating 
model.


We now compute the diagnostics of these six conformal prediction 
regions and the highest density prediction region, and we reproduce 
Table 2 in \citet{eck2019conformal}.  
We start with the computation of marginal and approximate average 
conditional coverage using functionality in the \texttt{conformal.glm} 
software.


<<>>=
## marginal coverages
marginal.gamma.trans <- local.coverage(region = gamma.transform, 
  data = dat, bins = 1, d = 2)
marginal.gaussian.trans <- local.coverage(
  region = gaussian.transform, data = dat, bins = 1, d = 2)
marginal.gamma.bin <- local.coverage(region = gamma.paraconfbin, 
  data = dat, bins = 1, d = 2)
marginal.gaussian.bin <- local.coverage(region = gaussian.paraconfbin, 
  data = dat, bins = 1, d = 2)
marginal.LS <- local.coverage(region = LS, data = dat, bins = 1, d = 2)
marginal.LSLW <- local.coverage(region = LSLW, data = dat, bins = 1, d = 2)
marginal.HD <- local.coverage(region = HD, data = dat, bins = 1, d = 2)
table.marginal <- matrix(c(marginal.gamma.trans, marginal.gaussian.trans, 
  marginal.gamma.bin, marginal.gaussian.bin, marginal.LSLW, marginal.LS, 
  marginal.HD), ncol = 7)
table.marginal <- round(table.marginal, 3)
colnames(table.marginal) <- c("gamma trans", "gaussian trans", "gamma bin", 
  "gaussian bin", "LSLW", "LS", "HD")
rownames(table.marginal) <- "marginal coverage"

## conditional coverages
d <- ncol(dat) - 2
conditional.gamma.trans <- local.coverage(region = gamma.transform, 
  data = dat, bins = 3, d = d)
conditional.gaussian.trans <- local.coverage(
  region = gaussian.transform, data = dat, bins = 3, d = d)
conditional.gamma.bin <- local.coverage(region = gamma.paraconfbin, 
  data = dat, bins = 3, d = d)
conditional.gaussian.bin <- local.coverage(region = gaussian.paraconfbin, 
  data = dat, bins = 3, d = d)
conditional.LS <- local.coverage(region = LS, data = dat, bins = 3, d = d)
conditional.LSLW <- local.coverage(region = LSLW, data = dat, bins = 3, d = d)
conditional.HD <- local.coverage(region = HD, data = dat, bins = 3, d = d)
table.conditional <- matrix(cbind(conditional.gamma.trans, 
  conditional.gaussian.trans, conditional.gamma.bin, conditional.gaussian.bin, 
  conditional.LSLW, conditional.LS, conditional.HD), ncol = 7)
table.conditional <- round(table.conditional, 3)
colnames(table.conditional) <- c("gamma trans", "gaussian trans", 
  "gamma bin", "gaussian bin", "LSLW", "LS", "HD")
avg.cond.coverage <- colMeans(table.conditional,na.rm = TRUE)  
@


We now compute the prediction error of each conformal prediction region.

<<>>=
pred.error.gamma.trans <- absolute.error(y = dat$glyhb, region = gamma.transform)
pred.error.gaussian.trans <- absolute.error(y = y, region = gaussian.transform)
pred.error.gamma.bin <- absolute.error(y = dat$glyhb, region = gamma.paraconfbin)
pred.error.gaussian.bin <- absolute.error(y = y, region = gaussian.paraconfbin)
pred.error.LSLW <- absolute.error(y = y, region = LSLW)
pred.error.LS <- absolute.error(y = y, region = LS)
pred.error.HD <- absolute.error(y = y, region = HD)
table.pred.error <- matrix(c(pred.error.gamma.trans, pred.error.gaussian.trans,
  pred.error.gamma.bin, pred.error.gaussian.bin, pred.error.LSLW, pred.error.LS, 
  pred.error.HD), ncol = 7)
colnames(table.pred.error) <- c("gamma trans", "gaussian trans", "gamma bin", 
  "gaussian bin ", "LSLW", "LS", "HD")
rownames(table.pred.error) <- "pred error"
@


We now compute the volume of each conformal prediction region.


<<>>=
## when no factor variables are present
volume.regions <- function(region, preds){
  if(class(region) == "list"){ 
    stop("Not appropriate for nonparametric conformal prediction regions")
  }
  n <- nrow(region)
  mat <- as.matrix(cbind(preds, region[, 1]))
  mat2 <- as.matrix(cbind(preds, region[, 2]))
  mat3 <- rbind(mat, mat2) 
  vol <- as.numeric(convhulln(mat3, option = "FA")$vol)
  vol
}

preds <- dat[, 2:4]
volume.gamma.trans <- volume.regions(region = gamma.transform, preds = preds)
volume.gaussian.trans <- volume.regions(region = gaussian.transform, preds = preds)
volume.gamma.bin <- volume.regions(region = gamma.paraconfbin, preds = preds)
volume.gaussian.bin <- volume.regions(region = gaussian.paraconfbin, preds = preds)
volume.LSLW <- volume.regions(region = LSLW, preds = preds)
volume.LS <- volume.regions(region = LS, preds = preds)
volume.HD <- volume.regions(region = HD, preds = preds)
table.volume <- matrix(c(volume.gamma.trans, volume.gaussian.trans, 
  volume.gamma.bin, volume.gaussian.bin, volume.LSLW, volume.LS, volume.HD), ncol = 7)
colnames(table.volume) <- c("gamma trans", "gaussian trans", "gamma bin", 
  "gaussian bin", "LSLW", "LS", "HD")
rownames(table.volume) <- "volume"


volume.factors <- function(region, bins = 1, data, object){
  if(class(region) == "list"){ 
    stop("Not appropriate for nonparametric conformal prediction regions")
  }
  n <- nrow(region)

  call <- object$call
  formula <- call$formula
  respname <- all.vars(formula)[1]
  index.factor.variables <- which(attr(terms(object), "dataClasses") == "factor")
  index.numeric.variables <- which(attr(terms(object), "dataClasses") == "numeric")
  data <- data[, respname != colnames(data)]
  index.data.factor.variables <- which(colnames(data) %in% names(index.factor.variables))
  index.data.numeric.variables <- which(colnames(data) %in% names(index.numeric.variables))    
  factors <- lapply(index.data.factor.variables, function(j) as.numeric(as.factor(data[, j])))
  data.by.factors <- split(data, factors, drop = FALSE)
  region.by.factors <- split(region, factors, drop = FALSE)
  matrix.region.by.factors <- lapply(region.by.factors, function(x){
    matrix(x, ncol = 2)
  })
  numeric.by.factors <- lapply(data.by.factors, function(x){ 
    mat <- x[, index.data.numeric.variables]
    colnames(mat) <- colnames(data)[index.data.numeric.variables]
    mat
  })
  bin.index.by.factors <- lapply(data.by.factors, function(x){ 
    if(nrow(x) == 0) return(0)
    mat <- as.matrix(x[, index.data.numeric.variables[-1]], 
      ncol = length(index.data.numeric.variables[-1]))
    find.index(mat = mat, wn = 1/bins, d = ncol(mat))
  })

  volume.factor <- sapply(1:length(region.by.factors), function(i){
    out <- sum(sapply(1:length(unique(bin.index.by.factors[[i]])), function(j){
      X <- rbind( 
        cbind(numeric.by.factors[[i]][which(bin.index.by.factors[[i]] == j), ], 
          matrix.region.by.factors[[i]][which(bin.index.by.factors[[i]] == j), 1]), 
        cbind(numeric.by.factors[[i]][which(bin.index.by.factors[[i]] == j), ], 
          matrix.region.by.factors[[i]][which(bin.index.by.factors[[i]] == j), 2])          
      )
      X <- X[, -1]
      vol <- as.numeric(convhulln(X, option = "FA")$vol) * nrow(X) / (2*n)
      vol
    }))
    return(out)
  })
     
  sum(volume.factor)  
}

volume.gamma.trans <- volume.factors(region = gamma.transform, 
  data = dat, object = m.gamma.log)
volume.gaussian.trans <- volume.factors(gaussian.transform, 
  data = dat, object = m.gaussian)
volume.gamma.bin <- volume.factors(region = gamma.paraconfbin, 
  data = dat, object = m.gamma.log)
volume.gaussian.bin <- volume.factors(gaussian.paraconfbin, 
  data = dat, object = m.gaussian)
volume.LSLW <- volume.factors(LSLW, 
  data = dat, object = m.gaussian)
volume.LS <- volume.factors(LS, 
  data = dat, object = m.gaussian)
volume.HD <- volume.factors(HD, 
  data = dat, object = m.gamma.log)

table.volume <- matrix(c(volume.gamma.trans, volume.gaussian.trans, 
  volume.gamma.bin, volume.gaussian.bin, volume.LSLW, volume.LS, 
  volume.HD), ncol = 7)
colnames(table.volume) <- c("gamma trans", "gaussian trans", "gamma bin", 
  "gaussian bin", "LSLW", "LS", "HD")
rownames(table.volume) <- "volume"
table.volume <- table.volume / 1e4
@


Table 2 and Figure 4 in \citet{eck2019conformal} are shown below. 


<<results = 'asis'>>=
diagnostics <- rbind(table.marginal, table.volume, 
  table.pred.error, avg.cond.coverage)
#diagnostics <- t(diagnostics)
xtable(diagnostics, digits = c(0, 3, 3, 3, 3, 3, 3, 3))
@



\begin{figure}
\begin{center}
<<echo = FALSE, eval = FALSE>>=
mfrow3d(2, 2)

# need to make weights unique so polygon is well defined. 
dat$weight = jitter(dat$weight)

## Gamma transform conformal
dat.gamma <- cbind(dat, gamma.transformconf)
upr <- dat.gamma$upr
lwr <- dat.gamma$lwr
x <- dat$age
y <- dat$glyhb
z <- dat$weight
age.factor <- cut(x, breaks = c(10,37,47,63,100))
AGEFACTOR <- c(25, 40, 55, 70)
dat_age <- split(dat.gamma, f = as.factor(age.factor))
dat_by_age <- lapply(1:length(levels(age.factor)), 
                     function(j){
  qux <- as.data.frame(cbind(dat_age[[j]], AGEFACTOR = AGEFACTOR[j]))
  index <- sort(qux$weight, index.return = TRUE)$ix
  qux[index, ]
})

#######################################
plot3d(x, y, z, col=rgb(0.5,0.5,0.5,alpha=0.5), type ="p", 
  xlab = "", zlab = "", ylab = "", xlim = c(19, 92), 
  zlim = c(75, 450), ylim = c(0, 18),
  box = FALSE, axes = FALSE)
rgl.viewpoint(theta = 220, phi = 0, zoom = 1.2, fov = 45)
axis3d(edge = "x--", nticks = 3)
axis3d(edge = "y+-", nticks = 4)
axis3d(edge = "z--", nticks = 3)
cex = 1.3
mtext3d("Age (years)",  edge = "x--", line = 2, cex=cex, at=50)
mtext3d("Weight (lbs)", edge = "z--", line = 2.5, cex=cex, at=250)
mtext3d("HbA1c (%)",    edge = "y+-", line = 2.5, cex=cex, at=7.5)
title3d(main="Gamma transform conformal", cex=2, line = 2)
material3d("red", alpha=0.3, shininess=5)

spn = 0.5
for(j in 1:length(dat_by_age)) {

  # smoothed upper and lower predictions
  pred_upr <- predict(loess(dat_by_age[[j]]$upr ~ dat_by_age[[j]]$weight, span=spn))
  pred_lwr <- predict(loess(dat_by_age[[j]]$lwr ~ dat_by_age[[j]]$weight, span=spn))

  # polygon vertices
  xvals = c(dat_by_age[[j]]$AGEFACTOR, dat_by_age[[j]]$AGEFACTOR)
  yvals = c(pred_upr, rev(pred_lwr))
  zvals = c(dat_by_age[[j]]$weight, rev(dat_by_age[[j]]$weight))

  # polygon is in (y,z)
  polygon3d(x=xvals, y=yvals, z=zvals, coords=c(2,3), fill=TRUE, col="red", 
            random=FALSE)
}


## Gamma binned conformal
dat.gamma <- cbind(dat, gamma.paraconfbin)
#dat.gaussian <- cbind(dat, conformal.gaussian)
#upr <- dat.gaussian$upr
#lwr <- dat.gaussian$lwr
#dat_age <- split(dat.gaussian, f = as.factor(age.factor))
upr <- dat.gamma$upr
lwr <- dat.gamma$lwr
dat_age <- split(dat.gamma, f = as.factor(age.factor))
dat_by_age <- lapply(1:length(levels(age.factor)), 
                     function(j){
  qux <- as.data.frame(cbind(dat_age[[j]], AGEFACTOR = AGEFACTOR[j]))
  index <- sort(qux$weight, index.return = TRUE)$ix
  qux[index, ]
})

#######################################
plot3d(x, y, z, col=rgb(0.5,0.5,0.5,alpha=0.5), type ="p", 
  xlab = "", zlab = "", ylab = "", xlim = c(19, 92), 
  zlim = c(75, 450), ylim = c(0, 18),
  box = FALSE, axes = FALSE)
rgl.viewpoint(theta = 220, phi = 0, zoom = 1.2, fov = 45)
axis3d(edge = "x--", nticks = 3)
axis3d(edge = "y+-", nticks = 4)
axis3d(edge = "z--", nticks = 3)
mtext3d("Age (years)",  edge = "x--", line = 2, cex=cex, at=50)
mtext3d("Weight (lbs)", edge = "z--", line = 2.5, cex=cex, at=250)
mtext3d("HbA1c (%)",    edge = "y+-", line = 2.5, cex=cex, at=7.5)
#title3d(main="Gaussian conformal", cex=2, line = 2)
title3d(main="Gamma binned conformal", cex=2, line = 2)
material3d("red", alpha=0.3, shininess=5)

for(j in 1:length(dat_by_age)) {

  # smoothed upper and lower predictions
  pred_upr <- predict(loess(dat_by_age[[j]]$upr ~ dat_by_age[[j]]$weight, span=spn))
  pred_lwr <- predict(loess(dat_by_age[[j]]$lwr ~ dat_by_age[[j]]$weight, span=spn))

  # polygon vertices
  xvals = c(dat_by_age[[j]]$AGEFACTOR, dat_by_age[[j]]$AGEFACTOR)
  yvals = c(pred_upr, rev(pred_lwr))
  zvals = c(dat_by_age[[j]]$weight, rev(dat_by_age[[j]]$weight))

  # polygon is in (y,z)
  polygon3d(x=xvals, y=yvals, z=zvals, coords=c(2,3), fill=TRUE, col="red")
}



## LS region
dat.LS <- cbind(dat, LS)
upr <- dat.LS$upr
lwr <- dat.LS$lwr
dat_age <- split(dat.LS, f = as.factor(age.factor))
dat_by_age <- lapply(1:length(levels(age.factor)), 
                     function(j){
  qux <- as.data.frame(cbind(dat_age[[j]], AGEFACTOR = AGEFACTOR[j]))
  index <- sort(qux$weight, index.return = TRUE)$ix
  qux[index, ]
})

#######################################
plot3d(x, y, z, col=rgb(0.5,0.5,0.5,alpha=0.5), type ="p", 
  xlab = "", zlab = "", ylab = "", xlim = c(19, 92), 
  zlim = c(75, 450), ylim = c(0, 18),
  box = FALSE, axes = FALSE)
rgl.viewpoint(theta = 220, phi = 0, zoom = 1.2, fov = 45)
axis3d(edge = "x--", nticks = 3)
axis3d(edge = "y+-", nticks = 4)
axis3d(edge = "z--", nticks = 3)
mtext3d("Age (years)",  edge = "x--", line = 2, cex=cex, at=50)
mtext3d("Weight (lbs)", edge = "z--", line = 2.5, cex=cex, at=250)
mtext3d("HbA1c (%)",    edge = "y+-", line = 2.5, cex=cex, at=7.5)
title3d(main="LS conformal", cex=2, line = 2)
material3d("red", alpha=0.3, shininess=5)

for(j in 1:length(dat_by_age)) {

  # smoothed upper and lower predictions
  pred_upr <- predict(loess(dat_by_age[[j]]$upr ~ dat_by_age[[j]]$weight, span=spn))
  pred_lwr <- predict(loess(dat_by_age[[j]]$lwr ~ dat_by_age[[j]]$weight, span=spn))

  # polygon vertices
  xvals = c(dat_by_age[[j]]$AGEFACTOR, dat_by_age[[j]]$AGEFACTOR)
  yvals = c(pred_upr, rev(pred_lwr))
  zvals = c(dat_by_age[[j]]$weight, rev(dat_by_age[[j]]$weight))

  # polygon is in (y,z)
  polygon3d(x=xvals, y=yvals, z=zvals, coords=c(2,3), fill=TRUE, col="red")
}


## LSLW region
dat.LSLW <- cbind(dat, LSLW)
upr <- dat.LSLW$upr
lwr <- dat.LSLW$lwr
dat_age <- split(dat.LSLW, f = as.factor(age.factor))
dat_by_age <- lapply(1:length(levels(age.factor)), 
                     function(j){
  qux <- as.data.frame(cbind(dat_age[[j]], AGEFACTOR = AGEFACTOR[j]))
  index <- sort(qux$weight, index.return = TRUE)$ix
  qux[index, ]
})

#######################################
plot3d(x, y, z, col=rgb(0.5,0.5,0.5,alpha=0.5), type ="p", 
  xlab = "", zlab = "", ylab = "", xlim = c(19, 92), 
  zlim = c(75, 450), ylim = c(0, 18),
  box = FALSE, axes = FALSE)
rgl.viewpoint(theta = 220, phi = 0, zoom = 1.2, fov = 45)
axis3d(edge = "x--", nticks = 3)
axis3d(edge = "y+-", nticks = 4)
axis3d(edge = "z--", nticks = 3)
mtext3d("Age (years)",  edge = "x--", line = 2, cex=cex, at=50)
mtext3d("Weight (lbs)", edge = "z--", line = 2.5, cex=cex, at=250)
mtext3d("HbA1c (%)",    edge = "y+-", line = 2.5, cex=cex, at=7.5)
title3d(main="LSLW conformal", cex=2, line = 2)
material3d("red", alpha=0.3, shininess=5)

for(j in 1:length(dat_by_age)) {

  # smoothed upper and lower predictions
  pred_upr <- predict(loess(dat_by_age[[j]]$upr ~ dat_by_age[[j]]$weight, span=spn))
  pred_lwr <- predict(loess(dat_by_age[[j]]$lwr ~ dat_by_age[[j]]$weight, span=spn))

  # polygon vertices
  xvals = c(dat_by_age[[j]]$AGEFACTOR, dat_by_age[[j]]$AGEFACTOR)
  yvals = c(pred_upr, rev(pred_lwr))
  zvals = c(dat_by_age[[j]]$weight, rev(dat_by_age[[j]]$weight))

  # polygon is in (y,z)
  polygon3d(x=xvals, y=yvals, z=zvals, coords=c(2,3), fill=TRUE, col="red")
}
@
\includegraphics[width=0.9\textwidth]{conformal3ddiabetes.png}
\end{center}
\caption{ 
  Figure 4 in \citet{eck2019conformal}.
  Conformal prediction regions for glycosylated hemoglobin projected onto the 
  age and weight predictor axes.
  %People with similar ages are grouped. \comment{what do you mean that people with similar ages are grouped?  Why? } 
  Upper and lower bounds of the conformal prediction region are loess smoothed for visual appearance.
  %\comment{Why?  What do they look like if you do not smooth? }
  The code that constructed this figure is displayed in the accompanying .Rnw file.
}
\label{Fig:3d-conformal-regions}
\end{figure}





\newpage
\section{Additional Gamma simulations}
\label{sec:Gamma}

For the simulations in this section we generate responses using a gamma 
regression model with one variable.  We specify the inverse link function 
(the defualt in the \texttt{glm} function) and we set 
$\beta = (1.25, -1)^T$.  This value of $\beta$ is chosen so that the generated 
Gamma data is increasing, on average, in $x$ and exhibits increasing 
variability in $x$.  We investigate the performance of the five prediction 
regions across different sample size and shape parameter combinations.  We 
consider sample sizes of $n \in \{150, 250, 500\}$ and shape parameter values 
of $\{0.5, 0.75, 1, 1.5, 2, 5, 7, 10, 12, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100\}$.  
The LS and LSLW conformal prediction regions are fit using a cubic regression 
model.  This model is simple and it fits this type of Gamma data better than a 
simple linear or quadratic regression model.  Note that as the shape parameter 
increases the cubic regression model fits the data better.  When $n = 150$ we 
build the parametric and nonparametric conformal prediction regions using 2 
bins.  When $n = 250, 500$ we build the parametric and nonparametric conformal 
prediction regions using 3 bins.  These number of bin choices correspond to 
the bin width asymptotics of \citet{lei2014distribution}.

The next subsection contains all the code necessary to reproduce our results 
in Section~\ref{sec:Gamma-Results}.



\subsection{Simulations}

We perform Monte Carlo simulations to investigate the coverage properties, 
size, and prediction error of the Gamma conformal prediction region under 
transformation...

<<>>=
beta <- c(1.25, -1)
gamma_simulator <- function(beta, n = 150, shape = 0.5, alpha = 0.10, B = 2){
  models <- lapply(1:B, FUN = function(j){
    p <- d <- length(beta) - 1
    x <- matrix(runif(n*p), ncol = p)
    rate <- (cbind(1, x) %*% beta) * shape
    y <- rgamma(n = n, shape = shape, rate = rate)
    y <- y / sd(y)
    dat <- data.frame(y = y, x = x)
    colnames(dat)[2:(p+1)] <- paste("x", 1:p, sep = "")

    ## generate the data (has functionality for different 
    ## families and link functions)
    fit <- glm(y ~ x1, family = "Gamma", data = dat, 
      x = TRUE, y = TRUE)  
  })

  funs <- lm.funs(intercept = TRUE)
  train.fun <- funs$train.fun
  predict.fun <- funs$predict.fun
  conformal_regions <- lapply(models, FUN = function(obj){
    x <- obj$x[, -1]
    y <- obj$y
    p1.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
      x0 = cbind(x,x^2,x^3), 
      train.fun = train.fun, predict.fun = predict.fun, 
      alpha = alpha)
    LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

    cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
    abs.resid <- abs(cubic.model$resid)
    smooth.call <- smooth.spline(x, abs.resid, 
      nknots = 10)
    lambda <- smooth.call$lambda
    df <- smooth.call$df
    mad.train.fun <- function(x, y, out = NULL){
      smooth.spline(x, y, lambda = lambda, 
      df = df, nknots = 10)
    }
    mad.predict.fun <- function(out, newx){
      predict(out, as.data.frame(newx))
    }
    p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
      x0 = cbind(x,x^2,x^3), 
      train.fun = train.fun, predict.fun = predict.fun, 
      mad.train.fun = mad.train.fun,
      mad.predict.fun = mad.predict.fun,
      alpha = alpha)
    LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)

    betaMLE <- coefficients(obj)
    shapeMLE <- as.numeric(gamma.shape(obj)[1])
    rateMLE <- cbind(1, x) %*% betaMLE * shapeMLE
    HDCI <- do.call(rbind, lapply(1:n, function(j){ 
      hdi(qgamma, 1 - alpha, shape = shapeMLE, rate = rateMLE[j, 1])
    }))

    conf <- conformal.glm(obj, nonparametric = TRUE, method = "both", 
      cores = 7)
    parabinCI <- conf$paraconfbin
    transformCI <- conf$transformconf
    nonparabinCI <- conf$nonparaconfbin 
 
    out = list(parabinCI = parabinCI, transformCI = transformCI, 
      nonparabinCI = nonparabinCI, LSLWCI = LSLWCI, LSCI = LSCI, 
      HDCI = HDCI)
    out  
  })

  diagnostics_regions <- lapply(1:B, FUN = function(j){

    obj <- conformal_regions[[j]]
    dat <- models[[j]]$data
    foo <- lapply(obj, FUN = function(region){

      output <- NULL
      if(class(region) == "matrix"){
        marginal.coverage <- local.coverage(region = region, 
          data = dat, d = p, bins = 1, at.data = "TRUE")
        local.coverage <- local.coverage(region = region, 
          data = dat, d = p, bins = bins, at.data = "TRUE")
        local.inx.coverage <- local.coverage(region = region, 
          data = dat, d = p, bins = 25, at.data = "TRUE")
        output <- c(marginal.coverage, local.coverage, 
          local.inx.coverage, mean(apply(region, 1, diff)), 
          absolute.error(y = y, region = region))
      }
      else{
        marginal.coverage <- local.coverage(region = region, 
          nonparametric = "TRUE", data = dat, d = p, bins = 1, 
          at.data = "TRUE")
        local.coverage <- local.coverage(region = region, 
          nonparametric = "TRUE", data = dat, d = p, bins = bins, 
          at.data = "TRUE")
        local.inx.coverage <- local.coverage(region = region, 
          nonparametric = "TRUE", data = dat, d = p, bins = 25, 
          at.data = "TRUE")
        output <- c(marginal.coverage, local.coverage, 
          local.inx.coverage, area.nonparametric(region),
          absolute.error.nonparametric(data = dat, 
            region = region))    
      }
      output
    })
    do.call(rbind, foo)

  })

  diagnostics_regions
}
@



The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $0.5$.

<<gamma.150.2.0.5, cache = TRUE>>=
set.seed(13)
beta <- c(1.25, -1)
bins <- 2
n <- 150
B <- 250
system.time(out.gamma.150.2.0.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 0.5))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $0.75$.

<<gamma.150.2.0.75, cache = TRUE>>=
system.time(out.gamma.150.2.0.75 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 0.75))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $1$.

<<gamma.150.2.1, cache = TRUE>>=
system.time(out.gamma.150.2.1 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 1))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $1.5$.

<<gamma.150.2.1.5, cache = TRUE>>=
system.time(out.gamma.150.2.1.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 1.5))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $2$.

<<gamma.150.2.2, cache = TRUE>>=
system.time(out.gamma.150.2.2 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 2))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $5$.

<<gamma.150.2.5, cache = TRUE>>=
system.time(out.gamma.150.2.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 5))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $7$.

<<gamma.150.2.7, cache = TRUE>>=
system.time(out.gamma.150.2.7 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 7))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $10$.

<<gamma.150.2.10, cache = TRUE>>=
system.time(out.gamma.150.2.10 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 10))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $12$.

<<gamma.150.2.12, cache = TRUE>>=
system.time(out.gamma.150.2.12 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 12))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $15$.

<<gamma.150.2.15, cache = TRUE>>=
system.time(out.gamma.150.2.15 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 15))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $20$.

<<gamma.150.2.20, cache = TRUE>>=
system.time(out.gamma.150.2.20 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 20))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $25$.

<<gamma.150.2.25, cache = TRUE>>=
system.time(out.gamma.150.2.25 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 25))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $30$.

<<gamma.150.2.30, cache = TRUE>>=
system.time(out.gamma.150.2.30 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 30))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $40$.

<<gamma.150.2.40, cache = TRUE>>=
system.time(out.gamma.150.2.40 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 40))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $50$.

<<gamma.150.2.50, cache = TRUE>>=
system.time(out.gamma.150.2.50 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 50))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $60$.

<<gamma.150.2.60, cache = TRUE>>=
system.time(out.gamma.150.2.60 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 60))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $70$.

<<gamma.150.2.70, cache = TRUE>>=
system.time(out.gamma.150.2.70 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 70))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $80$.

<<gamma.150.2.80, cache = TRUE>>=
system.time(out.gamma.150.2.80 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 80))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $90$.

<<gamma.150.2.90, cache = TRUE>>=
system.time(out.gamma.150.2.90 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 90))
})))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $100$.

<<gamma.150.2.100, cache = TRUE>>=
system.time(out.gamma.150.2.100 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma_simulator(beta = beta, n = n, 
      shape = 100))
})))
@







%% n = 250
The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $0.5$.

<<gamma.250.3.0.5, cache = TRUE>>=
set.seed(13)
beta <- c(1.25, -1)
bins <- 3
n <- 250
B <- 50
system.time(out.gamma.250.3.0.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 0.5))
})))
@

<<>>=
gamma.250.3.0.5 <- cbind(
  rowMeans(out.gamma.250.3.0.5, na.rm = TRUE),  
  apply(out.gamma.250.3.0.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $0.75$.

<<gamma.250.3.0.75, cache = TRUE>>=
system.time(out.gamma.250.3.0.75 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 0.75))
})))
@

<<>>=
gamma.250.3.0.75 <- cbind( 
  rowMeans(out.gamma.250.3.0.75, na.rm = TRUE),  
  apply(out.gamma.250.3.0.75, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $1$.

<<gamma.250.3.1, cache = TRUE>>=
system.time(out.gamma.250.3.1 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 1))
})))
@

<<>>=
gamma.250.3.1 <- cbind( 
  rowMeans(out.gamma.250.3.1, na.rm = TRUE),  
  apply(out.gamma.250.3.1, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $1.5$.

<<gamma.250.3.1.5, cache = TRUE>>=
system.time(out.gamma.250.3.1.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 1.5))
})))
@

<<>>=
gamma.250.3.1.5 <- cbind( 
  rowMeans(out.gamma.250.3.1.5, na.rm = TRUE),  
  apply(out.gamma.250.3.1.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $2$.

<<gamma.250.3.2, cache = TRUE>>=
system.time(out.gamma.250.3.2 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 2))
})))      
@

<<>>=
gamma.250.3.2 <- cbind( 
  rowMeans(out.gamma.250.3.2, na.rm = TRUE),  
  apply(out.gamma.250.3.2, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $5$.

<<gamma.250.3.5, cache = TRUE>>=
system.time(out.gamma.250.3.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 5))
})))
@

<<>>=
gamma.250.3.5 <- cbind( 
  rowMeans(out.gamma.250.3.5, na.rm = TRUE),  
  apply(out.gamma.250.3.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $7$.

<<gamma.250.3.7, cache = TRUE>>=
system.time(out.gamma.250.3.7 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 7))
})))
@

<<>>=
gamma.250.3.7 <- cbind( 
  rowMeans(out.gamma.250.3.7, na.rm = TRUE),  
  apply(out.gamma.250.3.7, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $10$.

<<gamma.250.3.10, cache = TRUE>>=
system.time(out.gamma.250.3.10 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 10))
})))
@

<<>>=
gamma.250.3.10 <- cbind( 
  rowMeans(out.gamma.250.3.10, na.rm = TRUE),  
  apply(out.gamma.250.3.10, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $12$.

<<gamma.250.3.12, cache = TRUE>>=
system.time(out.gamma.250.3.12 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 12))
})))
@

<<>>=
gamma.250.3.12 <- cbind( 
  rowMeans(out.gamma.250.3.12, na.rm = TRUE),  
  apply(out.gamma.250.3.12, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $15$.

<<gamma.250.3.15, cache = TRUE>>=
system.time(out.gamma.250.3.15 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 15))
})))
@

<<>>=
gamma.250.3.15 <- cbind( 
  rowMeans(out.gamma.250.3.15, na.rm = TRUE),  
  apply(out.gamma.250.3.15, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $20$.

<<gamma.250.3.20, cache = TRUE>>=
system.time(out.gamma.250.3.20 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 20))
})))
@

<<>>=
gamma.250.3.20 <- cbind( 
  rowMeans(out.gamma.250.3.20, na.rm = TRUE),  
  apply(out.gamma.250.3.20, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $25$.

<<gamma.250.3.25, cache = TRUE>>=
system.time(out.gamma.250.3.25 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 25))
})))
@

<<>>=
gamma.250.3.25 <- cbind( 
  rowMeans(out.gamma.250.3.25, na.rm = TRUE),  
  apply(out.gamma.250.3.25, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

Reorganize the output.

<<>>=
para.area.gamma.250 <- nonpara.area.gamma.250 <- 
  LS.area.gamma.250 <- LSLW.area.gamma.250 <- 
  HD.area.gamma.250 <- NULL
para.error.gamma.250 <- nonpara.error.gamma.250 <- 
  LS.error.gamma.250 <- LSLW.error.gamma.250 <- 
  HD.error.gamma.250 <- NULL
para.marginal.gamma.250 <- nonpara.marginal.gamma.250 <- 
  LS.marginal.gamma.250 <- LSLW.marginal.gamma.250 <- 
  HD.marginal.gamma.250 <- NULL
para.local.gamma.250 <- nonpara.local.gamma.250 <- 
  LS.local.gamma.250 <- LSLW.local.gamma.250 <- 
  HD.local.gamma.250 <- NULL
para.inx.gamma.250 <- nonpara.inx.gamma.250 <- 
  LS.inx.gamma.250 <- LSLW.inx.gamma.250 <- 
  HD.inx.gamma.250 <- NULL  
shapes <- c(0.5, 0.75, 1, 1.5, 2, 5, 7, 10, 12, 15, 20, 25)
for(j in shapes ){
  internal.output <- eval(parse(text=paste("gamma.250.3", j, sep = ".")))
  k <- which(shapes == j)
  para.marginal.gamma.250[k] <- as.numeric(internal.output[1, 1])
  para.local.gamma.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[2:4, 1])
  para.inx.gamma.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[5:29, 1])
  para.error.gamma.250[k] <- as.numeric(internal.output[30, 1]) 
  para.area.gamma.250[k] <- as.numeric(internal.output[31, 1])
  nonpara.marginal.gamma.250[k] <- as.numeric(internal.output[32, 1])
  nonpara.local.gamma.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[33:35, 1])
  nonpara.inx.gamma.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[36:60, 1])
  nonpara.error.gamma.250[k] <- as.numeric(internal.output[61, 1]) 
  nonpara.area.gamma.250[k] <- as.numeric(internal.output[62, 1])
  LS.marginal.gamma.250[k] <- as.numeric(internal.output[63, 1])  
  LS.local.gamma.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[64:66, 1])
  LS.inx.gamma.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[67:91, 1])
  LS.error.gamma.250[k] <- as.numeric(internal.output[92, 1]) 
  LS.area.gamma.250[k] <- as.numeric(internal.output[93, 1])
  LSLW.marginal.gamma.250[k] <- as.numeric(internal.output[94, 1])  
  LSLW.local.gamma.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[95:97, 1])
  LSLW.inx.gamma.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[98:122, 1])
  LSLW.error.gamma.250[k] <- as.numeric(internal.output[123, 1]) 
  LSLW.area.gamma.250[k] <- as.numeric(internal.output[124, 1])
  HD.marginal.gamma.250[k] <- as.numeric(internal.output[125, 1])
  HD.local.gamma.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[126:128, 1])
  HD.inx.gamma.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[129:153, 1])
  HD.error.gamma.250[k] <- as.numeric(internal.output[154, 1]) 
  HD.area.gamma.250[k] <- as.numeric(internal.output[155, 1])      
}
@


%% n = 500
The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $0.5$. 

<<gamma.500.3.0.5, cache = TRUE>>=
set.seed(13)
beta <- c(1.25, -1)
bins <- 3
n <- 500
B <- 50
system.time(out.gamma.500.3.0.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 0.5))
})))
@

<<>>=
gamma.500.3.0.5 <- cbind(
  rowMeans(out.gamma.500.3.0.5, na.rm = TRUE),  
  apply(out.gamma.500.3.0.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $0.75$.

<<gamma.500.3.0.75, cache = TRUE>>=
system.time(out.gamma.500.3.0.75 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 0.75))
})))
@

<<>>=
gamma.500.3.0.75 <- cbind( 
  rowMeans(out.gamma.500.3.0.75, na.rm = TRUE),  
  apply(out.gamma.500.3.0.75, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $1$.

<<gamma.500.3.1, cache = TRUE>>=
system.time(out.gamma.500.3.1 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 1))
})))
@

<<>>=
gamma.500.3.1 <- cbind( 
  rowMeans(out.gamma.500.3.1, na.rm = TRUE),  
  apply(out.gamma.500.3.1, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $1.5$.

<<gamma.500.3.1.5, cache = TRUE>>=
system.time(out.gamma.500.3.1.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 1.5))
})))
@

<<>>=
gamma.500.3.1.5 <- cbind( 
  rowMeans(out.gamma.500.3.1.5, na.rm = TRUE),  
  apply(out.gamma.500.3.1.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $2$.

<<gamma.500.3.2, cache = TRUE>>=
system.time(out.gamma.500.3.2 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 2))
})))
@

<<>>=
gamma.500.3.2 <- cbind( 
  rowMeans(out.gamma.500.3.2, na.rm = TRUE),  
  apply(out.gamma.500.3.2, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $5$.

<<gamma.500.3.5, cache = TRUE>>=
system.time(out.gamma.500.3.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 5))
})))
@

<<>>=
gamma.500.3.5 <- cbind( 
  rowMeans(out.gamma.500.3.5, na.rm = TRUE),  
  apply(out.gamma.500.3.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $7$.

<<gamma.500.3.7, cache = TRUE>>=
system.time(out.gamma.500.3.7 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 7))
})))
@

<<>>=
gamma.500.3.7 <- cbind( 
  rowMeans(out.gamma.500.3.7, na.rm = TRUE),  
  apply(out.gamma.500.3.7, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $10$.

<<gamma.500.3.10, cache = TRUE>>=
system.time(out.gamma.500.3.10 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 10))
})))
@

<<>>=
gamma.500.3.10 <- cbind( 
  rowMeans(out.gamma.500.3.10, na.rm = TRUE),  
  apply(out.gamma.500.3.10, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $12$.

<<gamma.500.3.12, cache = TRUE>>=
system.time(out.gamma.500.3.12 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 12))
})))
@

<<>>=
gamma.500.3.12 <- cbind( 
  rowMeans(out.gamma.500.3.12, na.rm = TRUE),  
  apply(out.gamma.500.3.12, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $15$.

<<gamma.500.3.15, cache = TRUE>>=
system.time(out.gamma.500.3.15 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 15))
})))
@

<<>>=
gamma.500.3.15 <- cbind( 
  rowMeans(out.gamma.500.3.15, na.rm = TRUE),  
  apply(out.gamma.500.3.15, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $20$.

<<gamma.500.3.20, cache = TRUE>>=
system.time(out.gamma.500.3.20 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 20))
})))
@

<<>>=
gamma.500.3.20 <- cbind( 
  rowMeans(out.gamma.500.3.20, na.rm = TRUE),  
  apply(out.gamma.500.3.20, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $25$.

<<gamma.500.3.25, cache = TRUE>>=
system.time(out.gamma.500.3.25 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(gamma.simulator(beta = beta, n = n, 
      bins = bins, shape = 25))
})))
@

<<>>=
gamma.500.3.25 <- cbind( 
  rowMeans(out.gamma.500.3.25, na.rm = TRUE),  
  apply(out.gamma.500.3.25, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@


Reorganize the output.

<<>>=
para.area.gamma.500 <- nonpara.area.gamma.500 <- 
  LS.area.gamma.500 <- LSLW.area.gamma.500 <- 
  HD.area.gamma.500 <- NULL
para.error.gamma.500 <- nonpara.error.gamma.500 <- 
  LS.error.gamma.500 <- LSLW.error.gamma.500 <- 
  HD.error.gamma.500 <- NULL
para.marginal.gamma.500 <- nonpara.marginal.gamma.500 <- 
  LS.marginal.gamma.500 <- LSLW.marginal.gamma.500 <- 
  HD.marginal.gamma.500 <- NULL
para.local.gamma.500 <- nonpara.local.gamma.500 <- 
  LS.local.gamma.500 <- LSLW.local.gamma.500 <- 
  HD.local.gamma.500 <- NULL
para.inx.gamma.500 <- nonpara.inx.gamma.500 <- 
  LS.inx.gamma.500 <- LSLW.inx.gamma.500 <- 
  HD.inx.gamma.500 <- NULL  
shapes <- c(0.5, 0.75, 1, 1.5, 2, 5, 7, 10, 12, 15, 20, 25)
for(j in shapes ){
  internal.output <- eval(parse(text=paste("gamma.500.3", j, sep = ".")))
  k <- which(shapes == j)
  para.marginal.gamma.500[k] <- as.numeric(internal.output[1, 1])
  para.local.gamma.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[2:4, 1])
  para.inx.gamma.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[5:29, 1])
  para.error.gamma.500[k] <- as.numeric(internal.output[30, 1]) 
  para.area.gamma.500[k] <- as.numeric(internal.output[31, 1])
  nonpara.marginal.gamma.500[k] <- as.numeric(internal.output[32, 1])
  nonpara.local.gamma.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[33:35, 1])
  nonpara.inx.gamma.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[36:60, 1])
  nonpara.error.gamma.500[k] <- as.numeric(internal.output[61, 1]) 
  nonpara.area.gamma.500[k] <- as.numeric(internal.output[62, 1])
  LS.marginal.gamma.500[k] <- as.numeric(internal.output[63, 1])  
  LS.local.gamma.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[64:66, 1])
  LS.inx.gamma.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[67:91, 1])
  LS.error.gamma.500[k] <- as.numeric(internal.output[92, 1]) 
  LS.area.gamma.500[k] <- as.numeric(internal.output[93, 1])
  LSLW.marginal.gamma.500[k] <- as.numeric(internal.output[94, 1])  
  LSLW.local.gamma.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[95:97, 1])
  LSLW.inx.gamma.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[98:122, 1])
  LSLW.error.gamma.500[k] <- as.numeric(internal.output[123, 1]) 
  LSLW.area.gamma.500[k] <- as.numeric(internal.output[124, 1])
  HD.marginal.gamma.500[k] <- as.numeric(internal.output[125, 1])
  HD.local.gamma.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[126:128, 1])
  HD.inx.gamma.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[129:153, 1])
  HD.error.gamma.500[k] <- as.numeric(internal.output[154, 1]) 
  HD.area.gamma.500[k] <- as.numeric(internal.output[155, 1])      
}
@




\newpage
\subsection{Results}
\label{sec:Gamma-Results}

Results form our simulations are depicted in 
Figures~\ref{Fig:gamma.150}-\ref{Fig:gamma.inx.500}.  
For all five prediction regions we depict the estimatated area, prediction 
error, and local coverage probabilities with respect to binning in 
Figures~\ref{Fig:gamma.150}, \ref{Fig:gamma.250}, and \ref{Fig:gamma.500} 
for $n = 150$, $250$, and $500$ respectively.  For all five prediction 
regions we depict the local coverage probabilities across $x$ in
Figures~\ref{Fig:gamma.inx.150}, \ref{Fig:gamma.inx.250}, and 
\ref{Fig:gamma.inx.500} for $n = 150$, $250$, and $500$ respectively.

From these simulations we see that the parametric conformal prediction region 
is similar to the HD prediciton region in area, prediction error, and 
appearance (as seen in Section~\ref{sec:gammaplots}).  Moreover, the 
parametric conformal prediction region possess finite-sample, albeit slightly 
conservative, local validity with respect to binning and possess nominal 
finite-sample conditional coverage over most of the support. 
The LSLW conformal prediction region is smaller than than both the parametric 
conformal prediction region and the HD prediction region.  However, it has a 
higher prediciton error than these regions and it is more conservative than 
the parametric conformal prediction region in most of our simulation 
settings.  It also does not fit the data well when the deviations about the 
estimated mean function are clearly not symmetric as evidenced by 
in Section~\ref{sec:gammaplots}.  These figures correspond to data generated 
from a Gamma distribution with small shape parameter values.  
The nonparametric conformal prediction region gives closer to nominal 
coverage and it possesses finite-sample local validity with respect to 
binning.  However, this prediction region is larger and gives higher 
prediciton error than the parametric and LSLW conformal prediction 
regions and HD prediction region.  The LS conformal prediciton region 
provides extreme overcoverage at small values of $x$ and extreme 
undercoverage at large values of $x$.  This prediction region is also larger 
and gives higher prediciton error than the parametric and LSLW conformal 
prediction regions and HD prediction region.


% Diagnostics, n = 150
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-gamma-150, echo = FALSE>>=
par(mfrow = c(2,2), oma = c(4,4,2,0), mar = c(1,1,1,2))
shapes <- c(0.5, 0.75, 1, 1.5, 2, 5, 7, 10, 12, 15, 20, 25, 
  30, 50, 50, 60, 70, 80, 90, 100)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), ylim = c(0, 0.55))
lines(log(shapes), para.area.gamma.150, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.area.gamma.150, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.area.gamma.150, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.area.gamma.150, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.area.gamma.150, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("area", side = 2, cex = 1.25, line = 2)

legend(-0.25, 0.55, legend=c("parametric", 
  "nonparametric", "LSLW", "LS", 
  "HD", "nominal coverage"), col=c("red", "green", "purple", 
  "black", "blue", "grey"), cex = 1.25, 
  lty=c(1,2,1,2,4,1), bty = "n")

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.50, 3.00))
lines(log(shapes), para.error.gamma.150, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.error.gamma.150, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.error.gamma.150, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.error.gamma.150, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.error.gamma.150, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("prediction error", side = 2, cex = 1.25, line = 2)

s <- length(shapes)
plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.80, 1.00))
lines(log(shapes), para.local.gamma.150[2*(1:s) - 1], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.150[2*(1:s) - 1], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.150[2*(1:s) - 1], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.150[2*(1:s) - 1], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.150[2*(1:s) - 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1)
axis(1); axis(2)
mtext("coverage when 0 < x <= 1/2", side = 2, cex = 1.25, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.80, 1.00))
lines(log(shapes), para.local.gamma.150[2*(1:s)], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.150[2*(1:s)], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.150[2*(1:s)], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.150[2*(1:s)], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.150[2*(1:s)], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1)
axis(1); axis(2)
mtext("coverage when 1/2 < x < 1", side = 2, cex = 1.25, line = 2)

mtext("log(shape)", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("Simulation Setting A", side = 3, cex = 1.25, line = 0.5, outer = TRUE)
@
\end{center}
\caption{This figure compares the performance of the 
  parametric,
  nonparametric,
  least squares, and 
  least squares locally weighted conformal prediciton region and the 
  highest density predcition region when $n = 150$ and the number of bins 
  equals 2.  
  The specific diagnostics used to compare these prediciton regions is the 
    area (top-left panel),
    prediction error (top-right panel), and
    the coverage probability with respect to binning (bottom row) 
    across shape parameter values.
  The average of 250 Monte Carlo samples at each shape parameter value in 
  these simulation settings form the lines that are depicted in this figure.}
\label{Fig:gamma.150}
\end{figure}


% local coverage, n = 150
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-gamma-inx-150, echo = FALSE>>=
par(mfrow = c(4,4), oma = c(4,4,1,0), mar = c(1,3,3,0))

# shape = 0.75
inx <- 0.02 + 0:24 * 0.04
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[26:50], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[26:50], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[26:50], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[26:50], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[26:50], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 0.75", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0,1), ylim = c(0.90, 0.98))
legend(-0.1, 0.98, legend=c("parametric", 
  "nonparametric", "LSLW", "LS", 
  "HD", "nominal coverage"), col=c("red", "green", "purple", 
  "black", "blue", "grey"), cex = 1,
  lty=c(1,2,1,2,4,1), bty = "n")

# shape = 1
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[51:75], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[51:75], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[51:75], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[51:75], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[51:75], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 1", side = 3, cex = 1, line = 2)

# shape = 2
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[101:125], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[101:125], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[101:125], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[101:125], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[101:125], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 2", side = 3, cex = 1, line = 2)

# shape = 5
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[126:150], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[126:150], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[126:150], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[126:150], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[126:150], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 5", side = 3, cex = 1, line = 2)

# shape = 7
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[151:175], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[151:175], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[151:175], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[151:175], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[151:175], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 7", side = 3, cex = 1, line = 2)

# shape = 10
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[176:200], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[176:200], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[176:200], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[176:200], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[176:200], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 10", side = 3, cex = 1, line = 2)

# shape = 12
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[201:225], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[201:225], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[201:225], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[201:225], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[201:225], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 12", side = 3, cex = 1, line = 2)

# shape = 15
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[226:250], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[226:250], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[226:250], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[226:250], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[226:250], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 15", side = 3, cex = 1, line = 2)

# shape = 20
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[251:275], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[251:275], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[251:275], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[251:275], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[251:275], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 20", side = 3, cex = 1, line = 2)

# shape = 25
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[276:300], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[276:300], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[276:300], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[276:300], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[276:300], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 25", side = 3, cex = 1, line = 2)

# shape = 30
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[301:325], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[301:325], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[301:325], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[301:325], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[301:325], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 30", side = 3, cex = 1, line = 2)

# shape = 40
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[326:350], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[326:350], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[326:350], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[326:350], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[326:350], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("shape = 40", side = 3, cex = 1, line = 2)

# shape = 50
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[351:375], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[351:375], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[351:375], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[351:375], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[351:375], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 50", side = 3, cex = 1, line = 2)

# shape = 60
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[376:400], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[376:400], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[376:400], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[376:400], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[376:400], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 60", side = 3, cex = 1, line = 2)

# shape = 70
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.150[401:425], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.150[401:425], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.150[401:425], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.150[401:425], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.150[401:425], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 70", side = 3, cex = 1, line = 2)


mtext("x", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("coverage", side = 2, cex = 1.25, line = 0, outer = TRUE)
@
\end{center}
\caption{Plot of the estimated coverage probabilities of prediction regions 
  across $x$ and shape parameter values when the model is correctly 
  specified, $n = 150$, and the number of bins is equal to $2$.}
\label{Fig:gamma.inx.150}
\end{figure}


% Diagnostics, n = 250
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-gamma-250, echo = FALSE>>=
par(mfrow = c(3,2), oma = c(4,4,3,0), mar = c(1,1,1,2))
shapes <- c(0.5, 0.75, 1, 1.5, 2, 5, 7, 10, 12, 15, 20, 25)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), ylim = c(0, 0.5))
lines(log(shapes), para.area.gamma.250, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.area.gamma.250, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.area.gamma.250, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.area.gamma.250, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.area.gamma.250, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("area", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.50, 3.00))
lines(log(shapes), para.error.gamma.250, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.error.gamma.250, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.error.gamma.250, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.error.gamma.250, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.error.gamma.250, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("prediction error", side = 2, cex = 1, line = 2)

s <- length(shapes)
plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.85, 1.00))
lines(log(shapes), para.local.gamma.250[3*(1:s) - 2], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.250[3*(1:s) - 2], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.250[3*(1:s) - 2], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.250[3*(1:s) - 2], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.250[3*(1:s) - 2], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 0 < x < 1/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.85, 1.00))
lines(log(shapes), para.local.gamma.250[3*(1:s) - 1], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.250[3*(1:s) - 1], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.250[3*(1:s) - 1], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.250[3*(1:s) - 1], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.250[3*(1:s) - 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 1/3 <= x < 2/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.70, 0.98))
lines(log(shapes), para.local.gamma.250[3*(1:s)], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.250[3*(1:s)], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.250[3*(1:s)], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.250[3*(1:s)], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.250[3*(1:s)], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 2/3 < x < 1", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.90, 0.98))
legend(0, 0.96, legend=c("parametric", 
  "nonparametric", "LSLW", "LS", 
  "HD", "nominal coverage"), col=c("red", "green", "purple", 
  "black", "blue", "grey"), cex = 1.5, 
  lty=c(1,2,1,2,4,1), bty = "n")

mtext("log(shape)", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("Simulation Setting A", side = 3, cex = 1.25, line = 0.5, outer = TRUE)
@
\end{center}
\caption{This figure compares the performance of the 
  parametric,
  nonparametric,
  least squares, and 
  least squares locally weighted conformal prediciton region and the 
  highest density prediction region when $n = 250$ and the number of bins 
  equals 3.  
  The specific diagnostics used to compare these prediciton regions is the 
    area (top-left panel),
    prediction error (top-right panel), and
    the coverage probability with respect to binning (bottom row) 
    across shape parameter values.
  The average of 50 Monte Carlo samples at each shape parameter value in 
  these simulation settings form the lines that are depicted in this figure.}
\label{Fig:gamma.250}
\end{figure}



% local coverage, n = 250
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-gamma-inx-250, echo = FALSE>>=
par(mfrow = c(4,4), oma = c(4,4,1,0), mar = c(1,3,3,0))

# shape = 0.50
inx <- 0.02 + 0:24 * 0.04
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[1:25], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[1:25], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[1:25], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[1:25], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[1:25], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 0.5", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0,1), ylim = c(0.90, 0.98))
legend(-0.1, 0.98, legend=c("parametric",
  "nonparametric", "LSLW", "LS", 
  "HD", "nominal coverage"), col=c("red", "green", "purple", 
  "black", "blue", "grey"), cex = 1,
  lty=c(1,2,1,2,4,1), bty = "n")

# shape = 0.75
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[26:50], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[26:50], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[26:50], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[26:50], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[26:50], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 0.75", side = 3, cex = 1, line = 2)

# shape = 1
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[51:75], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[51:75], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[51:75], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[51:75], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[51:75], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 1", side = 3, cex = 1, line = 2)

# shape = 1.5
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[76:100], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[76:100], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[76:100], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[76:100], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[76:100], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 1.5", side = 3, cex = 1, line = 2)

# shape = 2
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[101:125], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[101:125], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[101:125], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[101:125], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[101:125], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 2", side = 3, cex = 1, line = 2)

# shape = 5
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[126:150], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[126:150], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[126:150], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[126:150], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[126:150], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 5", side = 3, cex = 1, line = 2)

# shape = 7
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[151:175], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[151:175], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[151:175], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[151:175], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[151:175], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 7", side = 3, cex = 1, line = 2)

# shape = 10
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[176:200], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[176:200], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[176:200], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[176:200], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[176:200], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 3, cex = 1, line = 2)

# shape = 12
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[201:225], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[201:225], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[201:225], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[201:225], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[201:225], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 12", side = 3, cex = 1, line = 2)

# shape = 15
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[226:250], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[226:250], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[226:250], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[226:250], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[226:250], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 15", side = 3, cex = 1, line = 2)

# shape = 20
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[251:275], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[251:275], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[251:275], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[251:275], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[251:275], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 20", side = 3, cex = 1, line = 2)

# shape = 25
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.250[276:300], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.250[276:300], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.250[276:300], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.250[276:300], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.250[276:300], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("shape = 25", side = 3, cex = 1, line = 2)

mtext("x", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("coverage", side = 2, cex = 1.25, line = 0, outer = TRUE)
@
\end{center}
\caption{Plot of the estimated coverage probabilities of prediction regions 
  across $x$ and shape parameter values when the model is correctly 
  specified, $n = 250$, and the number of bins is equal to $3$.}
\label{Fig:gamma.inx.250}
\end{figure}



% Diagnostics, n = 500
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-gamma-500, echo = FALSE>>=
par(mfrow = c(3,2), oma = c(4,4,2,0), mar = c(1,1,1,2))
shapes <- c(0.5, 0.75, 1, 1.5, 2, 5, 7, 10, 12, 15, 20, 25)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), ylim = c(0, 0.5))
lines(log(shapes), para.area.gamma.500, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.area.gamma.500, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.area.gamma.500, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.area.gamma.500, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.area.gamma.500, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("area", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.50, 3.00))
lines(log(shapes), para.error.gamma.500, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.error.gamma.500, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.error.gamma.500, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.error.gamma.500, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.error.gamma.500, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("prediction error", side = 2, cex = 1, line = 2)

s <- length(shapes)
plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.85, 1.00))
lines(log(shapes), para.local.gamma.500[3*(1:s) - 2], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.500[3*(1:s) - 2], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.500[3*(1:s) - 2], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.500[3*(1:s) - 2], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.500[3*(1:s) - 2], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 0 < x < 1/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.85, 1.00))
lines(log(shapes), para.local.gamma.500[3*(1:s) - 1], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.500[3*(1:s) - 1], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.500[3*(1:s) - 1], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.500[3*(1:s) - 1], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.500[3*(1:s) - 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 1/3 <= x < 2/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.70, 0.98))
lines(log(shapes), para.local.gamma.500[3*(1:s)], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.gamma.500[3*(1:s)], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.gamma.500[3*(1:s)], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.gamma.500[3*(1:s)], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.gamma.500[3*(1:s)], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 2/3 < x < 1", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.90, 0.98))
legend(0, 0.96, legend=c("parametric",  
  "nonparametric", "LSLW", "LS", 
  "HD", "nominal coverage"), col=c("red", "green", "purple", 
  "black", "blue", "grey"), cex = 1.5, 
  lty=c(1,2,1,2,4,1), bty = "n")

mtext("log(shape)", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("Simulation Setting A", side = 3, cex = 1.25, line = 0.5, outer = TRUE)
@
\end{center}
\caption{Diagnostic plots for prediction regions when the model is correctly 
  specified, $n = 500$, and the number of bins is equal to $3$.}
\label{Fig:gamma.500}
\end{figure}



% local coverage, n = 500
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-gamma-inx-500, echo = FALSE>>=
par(mfrow = c(4,4), oma = c(4,4,1,0), mar = c(1,3,3,0))

# shape = 0.50
inx <- 0.02 + 0:24 * 0.04
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[1:25], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[1:25], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[1:25], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[1:25], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[1:25], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 0.5", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.90, 0.98))
legend(-0.1, 0.98, legend=c("parametric", 
  "nonparametric", "LSLW", "LS", 
  "HD", "nominal coverage"), col=c("red", "green", "purple", 
  "black", "blue", "grey"), cex = 1, 
  lty=c(1,2,1,2,4,1), bty = "n")

# shape = 0.75
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[26:50], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[26:50], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[26:50], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[26:50], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[26:50], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 0.75", side = 3, cex = 1, line = 2)

# shape = 1
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[51:75], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[51:75], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[51:75], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[51:75], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[51:75], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 1", side = 3, cex = 1, line = 2)

# shape = 1.5
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[76:100], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[76:100], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[76:100], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[76:100], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[76:100], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 1.5", side = 3, cex = 1, line = 2)

# shape = 2
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[101:125], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[101:125], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[101:125], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[101:125], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[101:125], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 2", side = 3, cex = 1, line = 2)

# shape = 5
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[126:150], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[126:150], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[126:150], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[126:150], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[126:150], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 5", side = 3, cex = 1, line = 2)

# shape = 7
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[151:175], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[151:175], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[151:175], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[151:175], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[151:175], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 7", side = 3, cex = 1, line = 2)

# shape = 10
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[176:200], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[176:200], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[176:200], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[176:200], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[176:200], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 3, cex = 1, line = 2)

# shape = 12
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[201:225], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[201:225], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[201:225], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[201:225], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[201:225], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 12", side = 3, cex = 1, line = 2)

# shape = 15
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[226:250], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[226:250], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[226:250], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[226:250], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[226:250], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 15", side = 3, cex = 1, line = 2)

# shape = 20
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[251:275], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[251:275], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[251:275], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[251:275], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[251:275], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 20", side = 3, cex = 1, line = 2)

# shape = 25
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.gamma.500[276:300], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.gamma.500[276:300], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.gamma.500[276:300], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.gamma.500[276:300], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.gamma.500[276:300], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("shape = 25", side = 3, cex = 1, line = 2)

mtext("x", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("coverage", side = 2, cex = 1.25, line = 0, outer = TRUE)
@
\end{center}
\caption{This figure compares the performance of the 
  parametric,
  nonparametric,
  least squares, and 
  least squares locally weighted conformal prediciton region and the 
  highest density prediction region when $n = 550$ and the number of bins 
  equals 3.  
  The specific diagnostics used to compare these prediciton regions is the 
    area (top-left panel),
    prediction error (top-right panel), and
    the coverage probability with respect to binning (bottom row) 
    across shape parameter values.
  The average of 50 Monte Carlo samples at each shape parameter value in 
  these simulation settings form the lines that are depicted in this figure.}
\label{Fig:gamma.inx.500}
\end{figure}







\newpage
\section{Gamma-Gaussian model misspecification}
\label{sec:misspec}

In this Section, we compare the parametric conformal prediction 
region, the nonparametric conformal prediction region, the LSLW conformal 
prediction region, the LS conformal prediction region, and the HD prediction 
region under model misspecification.  The data generating process is Gamma 
with an inverse link function and we set $\beta = (0.5, 1)^T$.
We consider sample sizes of $n \in \{150, 250, 500\}$ and shape parameter 
values of $\{5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100\}$ when $n = 150$ and 
shape parameter values of $\{5, 20, 40, 60, 80, 100\}$ when $n = 250, 500$.  
This value of $\beta$ and these shape parameter values are chosen so that 
errors about a cubic regression model appear to be almost symmetric.  In this 
analysis the parametric, LSLW, and LS conformal prediction regions and the HD 
prediction region are fit assuming this misspecified cubic regression model 
with homoscedastic normal errors.  When $n = 150$ we build the parametric and 
nonparametric conformal prediction regions using 2 bins.  When $n = 250, 500$ 
we build the parametric and nonparametric conformal prediction regions using 
3 bins.  These number of bin choices correspond to the bin width asymptotics 
of \citet{lei2014distribution}. 



\subsection{Simulations}

The following function computes our diagnostic measures for the five 
prediction regions under investigation in the univariate case where data 
is assumed to be Gamma with inverse link function and the fitted model is 
Gaussian with a cubic fit.  

<<>>=
misspec.simulator <- function(n = 500, alpha = 0.10, beta, 
  shape, bins = 3, family = "Gamma", link = "inverse", 
  confamily = "gaussian", parametric = TRUE, 
  nonparametric = TRUE, LS = TRUE, LSLW = TRUE, HD = TRUE, 
  oracle = FALSE, cores = 6){

  p <- d <- length(beta) - 1
  x <- matrix(runif(n), ncol = p)
  y <- rep(0,n)
  data <- NULL

  ## set up partition
  if(class(bins) == "NULL"){ 
    wn <- min(1/ floor(1 / (log(n)/n)^(1/(d+3))), 1/2)
    bins <- 1 / wn
  }

  ## generate the data (has functionality for different 
  ## families and link functions)
  if(family == "Gamma"){
    if(link == "identity"){
      rate <- (1 / (cbind(1, x) %*% beta)) * shape
      y <- rgamma(n = n, shape = shape, rate = rate)
      y <- y / sd(y)
      data <- data.frame(y = y, x = x)
      colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")
    }
    if(link == "inverse"){
      rate <- (cbind(1, x) %*% beta) * shape
      y <- rgamma(n = n, shape = shape, rate = rate)
      y <- y / sd(y)
      data <- data.frame(y = y, x = x)
      colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")
    }
    if(link == "log"){
      rate <- (1 / exp(cbind(1, x) %*% beta)) * shape
      y <- rgamma(n = n, shape = shape, rate = rate)
      y <- y / sd(y)
      data <- data.frame(y = y, x = x)
      colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")
    }
  }

  if(family == "gaussian"){
    mu <- cbind(1, x) %*% beta
    y <- rnorm(n = n, mean = mu, sd = sd)
    data <- data.frame(y = y, x = x)
    colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")
  }

  if(family == "inverse.gaussian"){
    mu = 1 / sqrt(cbind(1, x) %*% beta)
    y <- rinvgauss(n = n, mean = mu)
    y <- y / sd(y)
    data <- data.frame(y = y, x = x)
    colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")
  }

  ## fit the misspecified cubic regression model
  fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), family = confamily, 
    data = data)
  paraCI <- nonparaCI <- LSCI <- LSLWCI <- HDCI <- 
    trueHDCI <- NULL
  formula <- fit$formula
  newdata <- data
  respname <- all.vars(formula)[1]
  newdata <- newdata[, !(colnames(data) %in% respname)]
  newdata <- as.matrix(newdata)

  ## obtain the prediction regions
  if(parametric){ 
    cpred <- conformal.glm(fit, parametric = TRUE, 
      nonparametric = FALSE, alpha = alpha,
      bins = bins, cores = cores)
    paraCI <- cpred$paraconformal
  }
  if(nonparametric){ 
    cpred <- conformal.glm(fit, parametric = FALSE, 
      nonparametric = TRUE, alpha = alpha,
      bins = bins, cores = cores)
    nonparaCI <- cpred$nonparaconformal
  }
  if(LS){
    p1.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
      x0 = cbind(x,x^2,x^3), 
      train.fun = train.fun, predict.fun = predict.fun, 
      alpha = alpha)
    LSCI <- cbind(p1.tibs$lo, p1.tibs$up)
  }
  if(LSLW){
    cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
    abs.resid <- abs(cubic.model$resid)
    smooth.call <- smooth.spline(x, abs.resid, 
      nknots = 10)
    lambda <- smooth.call$lambda
    df <- smooth.call$df
    mad.train.fun <- function(x, y, out = NULL){
      smooth.spline(x[, 1], y, lambda = lambda, 
      df = df, nknots = 10)
    }
    p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
      x0 = cbind(x,x^2,x^3), 
      train.fun = train.fun, predict.fun = predict.fun, 
      mad.train.fun = mad.train.fun,
      mad.predict.fun = mad.predict.fun,
      alpha = alpha)
    LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)
  }
  if(HD){
    if(oracle){
      fit.gamma <- glm(y ~ x1, family = "Gamma", data = data)
      betaMLE <- coefficients(fit.gamma)
      shapeMLE <- as.numeric(gamma.shape(fit.gamma)[1])
      rateMLE <- cbind(1, newdata) %*% betaMLE * shapeMLE
      trueHDCI <- do.call(rbind, lapply(1:nrow(newdata), function(j){ 
        hdi(qgamma, 1 - alpha, shape = shapeMLE, rate = rateMLE[j, 1])
      }))
    }
    fit = lm(y ~ x1 + I(x1^2) + I(x1^3), data = data)
    betaMLE <- coefficients(fit)
    sdMLE <- summary(fit)$sigma
    meanMLE <- as.numeric(cbind(1, x, x^2, x^3) %*% betaMLE)
    HDCI <- do.call(rbind, lapply(1:nrow(newdata), function(j){ 
      hdi(qnorm, 1 - alpha, sd = sdMLE, mean = meanMLE[j])
    }))
  }
    
  ## local coverage prediction regions
  output.parametric <- output.nonparametric <- 
    output.LS <- output.LSLW <- output.HD <-
    output.trueHD <- rep(NA, bins + 1)
  if(parametric){
    marginal.parametric <- local.coverage(region = paraCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")  
    local.parametric <- local.coverage(region = paraCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.parametric <- local.coverage(region = paraCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.parametric <- c(marginal.parametric, local.parametric, 
      local.inx.parametric, 
      mean(apply(paraCI, 1, diff)), 
      absolute.error(y = y, region = paraCI))
  }
  if(nonparametric){
    marginal.nonparametric <- local.coverage(region = nonparaCI, 
      nonparametric = "TRUE", data = data, d = p, bins = 1, 
      at.data = "TRUE")
    local.nonparametric <- local.coverage(region = nonparaCI, 
      nonparametric = "TRUE", data = data, d = p, bins = bins, 
      at.data = "TRUE")
    local.inx.nonparametric <- local.coverage(region = nonparaCI, 
      nonparametric = "TRUE", data = data, d = p, bins = 25, 
      at.data = "TRUE")
    output.nonparametric <- 
      c(marginal.nonparametric, local.nonparametric, 
        local.inx.nonparametric, 
        area.nonparametric(nonparaCI),
        absolute.error.nonparametric(data = data, 
          region = nonparaCI))
  }
  if(LS){
    marginal.LS <- local.coverage(region = LSCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")
    local.LS <- local.coverage(region = LSCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.LS <- local.coverage(region = LSCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.LS <- c(marginal.LS, local.LS, local.inx.LS, 
      mean(apply(LSCI, 1, diff)), 
      absolute.error(y = y, region = LSCI))
  }
  if(LSLW){
    marginal.LSLW <- local.coverage(region = LSLWCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")
    local.LSLW <- local.coverage(region = LSLWCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.LSLW <- local.coverage(region = LSLWCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.LSLW <- c(marginal.LSLW, local.LSLW, local.inx.LSLW, 
      mean(apply(LSLWCI, 1, diff)), 
      absolute.error(y = y, region = LSLWCI))      
  }
  if(HD){
    marginal.HD <- local.coverage(region = HDCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")
    local.HD <- local.coverage(region = HDCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.HD <- local.coverage(region = HDCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.HD <- c(marginal.HD, local.HD, local.inx.HD, 
      mean(apply(HDCI, 1, diff)), 
      absolute.error(y = y, region = HDCI))
    if(oracle){
      marginal.trueHD <- local.coverage(region = trueHDCI, 
        data = data, d = p, bins = 1, at.data = "TRUE")
      local.trueHD <- local.coverage(region = trueHDCI, 
        data = data, d = p, bins = bins, at.data = "TRUE")
      local.inx.trueHD <- local.coverage(region = trueHDCI, 
        data = data, d = p, bins = 25, at.data = "TRUE")
      output.trueHD <- c(marginal.trueHD, local.trueHD, 
        local.inx.trueHD, mean(apply(trueHDCI, 1, diff)), 
        absolute.error(y = y, region = trueHDCI))
    }
  }

  output <- list(output.parametric = output.parametric, 
    output.nonparametric = output.nonparametric,
    output.LS = output.LS, 
    output.LSLW = output.LSLW, 
    output.HD = output.HD, 
    output.trueHD = output.trueHD)
  output

}
@

%The following performs our Monte Carlo simulation of $B = 250$ iterations 
%when $n = 150$ and shape = $0.5$.

%<<misspec.150.2.0.5, cache = TRUE>>=
%set.seed(13)
%beta <- c(0.5, 1)
%n <- 150
%bins <- 2
%B <- 250
%system.time(out.misspec.150.2.0.5 <- do.call(cbind, 
%  lapply(1:B, FUN = function(j){
%    unlist(misspec.simulator(beta = beta, n = n, 
%      oracle = TRUE, bins = bins, shape = 0.5))
%})))
%@

%<<>>=
%misspec.150.2.0.5 <- cbind(
%  rowMeans(out.misspec.150.2.0.5, na.rm = TRUE),  
%  apply(out.misspec.150.2.0.5, 1, 
%  FUN = function(x){ 
%    sds <- sd(x, na.rm = TRUE)
%    lengths <- length(which(!is.na(x)))
%    sds / sqrt(lengths)
%  }))
%@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $0.75$.

<<misspec.150.2.0.75, cache = TRUE>>=
set.seed(13)
beta <- c(0.5, 1)
n <- 150
bins <- 2
B <- 250
system.time(out.misspec.150.2.0.75 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 0.75))
})))
@

<<>>=
misspec.150.2.0.75 <- cbind(
  rowMeans(out.misspec.150.2.0.75, na.rm = TRUE),  
  apply(out.misspec.150.2.0.75, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $1$.

<<misspec.150.2.1, cache = TRUE>>=
system.time(out.misspec.150.2.1 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 1))
})))
@

<<>>=
misspec.150.2.1 <- cbind(
  rowMeans(out.misspec.150.2.1, na.rm = TRUE),  
  apply(out.misspec.150.2.1, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $2$.

<<misspec.150.2.2, cache = TRUE>>=
system.time(out.misspec.150.2.2 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 2))
})))
@

<<>>=
misspec.150.2.2 <- cbind(
  rowMeans(out.misspec.150.2.2, na.rm = TRUE),  
  apply(out.misspec.150.2.2, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $5$.

<<misspec.150.2.5, cache = TRUE>>=
system.time(out.misspec.150.2.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 5))
})))
@

<<>>=
misspec.150.2.5 <- cbind(
  rowMeans(out.misspec.150.2.5, na.rm = TRUE),  
  apply(out.misspec.150.2.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $7$.

<<misspec.150.2.7, cache = TRUE>>=
system.time(out.misspec.150.2.7 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 7))
})))
@

<<>>=
misspec.150.2.7 <- cbind(
  rowMeans(out.misspec.150.2.7, na.rm = TRUE),  
  apply(out.misspec.150.2.7, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $10$.

<<misspec.150.2.10, cache = TRUE>>=
system.time(out.misspec.150.2.10 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 10))
})))
@

<<>>=
misspec.150.2.10 <- cbind(
  rowMeans(out.misspec.150.2.10, na.rm = TRUE),  
  apply(out.misspec.150.2.10, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $12$.

<<misspec.150.2.12, cache = TRUE>>=
system.time(out.misspec.150.2.12 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 12))
})))
@

<<>>=
misspec.150.2.12 <- cbind(
  rowMeans(out.misspec.150.2.12, na.rm = TRUE),  
  apply(out.misspec.150.2.12, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $15$.

<<misspec.150.2.15, cache = TRUE>>=
system.time(out.misspec.150.2.15 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 15))
})))
@

<<>>=
misspec.150.2.15 <- cbind(
  rowMeans(out.misspec.150.2.15, na.rm = TRUE),  
  apply(out.misspec.150.2.15, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $20$.

<<misspec.150.2.20, cache = TRUE>>=
system.time(out.misspec.150.2.20 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 20))
})))
@

<<>>=
misspec.150.2.20 <- cbind(
  rowMeans(out.misspec.150.2.20, na.rm = TRUE),  
  apply(out.misspec.150.2.20, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $25$.

<<misspec.150.2.25, cache = TRUE>>=
system.time(out.misspec.150.2.25 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 25))
})))
@

<<>>=
misspec.150.2.25 <- cbind(
  rowMeans(out.misspec.150.2.25, na.rm = TRUE),  
  apply(out.misspec.150.2.25, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@


The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $30$.

<<misspec.150.2.30, cache = TRUE>>=
system.time(out.misspec.150.2.30 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 30))
})))
@

<<>>=
misspec.150.2.30 <- cbind( 
  rowMeans(out.misspec.150.2.30, na.rm = TRUE),  
  apply(out.misspec.150.2.30, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $40$.

<<misspec.150.2.40, cache = TRUE>>=
system.time(out.misspec.150.2.40 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 40))
})))
@

<<>>=
misspec.150.2.40 <- cbind( 
  rowMeans(out.misspec.150.2.40, na.rm = TRUE),  
  apply(out.misspec.150.2.40, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $50$.

<<misspec.150.2.50, cache = TRUE>>=
system.time(out.misspec.150.2.50 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 50))
})))
@

<<>>=
misspec.150.2.50 <- cbind( 
  rowMeans(out.misspec.150.2.50, na.rm = TRUE),  
  apply(out.misspec.150.2.50, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $60$.

<<misspec.150.2.60, cache = TRUE>>=
system.time(out.misspec.150.2.60 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 60))
})))
@

<<>>=
misspec.150.2.60 <- cbind( 
  rowMeans(out.misspec.150.2.60, na.rm = TRUE),  
  apply(out.misspec.150.2.60, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $70$.

<<misspec.150.2.70, cache = TRUE>>=
system.time(out.misspec.150.2.70 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 70))
})))
@

<<>>=
misspec.150.2.70 <- cbind( 
  rowMeans(out.misspec.150.2.70, na.rm = TRUE),  
  apply(out.misspec.150.2.70, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $80$.

<<misspec.150.2.80, cache = TRUE>>=
system.time(out.misspec.150.2.80 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 80))
})))
@

<<>>=
misspec.150.2.80 <- cbind( 
  rowMeans(out.misspec.150.2.80, na.rm = TRUE),  
  apply(out.misspec.150.2.80, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $90$.

<<misspec.150.2.90, cache = TRUE>>=
system.time(out.misspec.150.2.90 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 90))
})))
@

<<>>=
misspec.150.2.90 <- cbind( 
  rowMeans(out.misspec.150.2.90, na.rm = TRUE),  
  apply(out.misspec.150.2.90, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 250$ iterations 
when $n = 150$ and shape = $100$.

<<misspec.150.2.100, cache = TRUE>>=
system.time(out.misspec.150.2.100 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      oracle = TRUE, bins = bins, shape = 100))
})))
@

<<>>=
misspec.150.2.100 <- cbind( 
  rowMeans(out.misspec.150.2.100, na.rm = TRUE),  
  apply(out.misspec.150.2.100, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@


Reorganize the output.

<<>>=
para.area.misspec.150 <- nonpara.area.misspec.150 <- 
  LS.area.misspec.150 <- LSLW.area.misspec.150 <- 
  HD.area.misspec.150 <- trueHD.area.misspec.150 <- NULL
para.error.misspec.150 <- nonpara.error.misspec.150 <- 
  LS.error.misspec.150 <- LSLW.error.misspec.150 <- 
  HD.error.misspec.150 <- trueHD.error.misspec.150 <- NULL
para.marginal.misspec.150 <- nonpara.marginal.misspec.150 <- 
  LS.marginal.misspec.150 <- LSLW.marginal.misspec.150 <- 
  HD.marginal.misspec.150 <- trueHD.marginal.misspec.150 <- NULL
para.local.misspec.150 <- nonpara.local.misspec.150 <- 
  LS.local.misspec.150 <- LSLW.local.misspec.150 <- 
  HD.local.misspec.150 <- trueHD.local.misspec.150 <- NULL
para.inx.misspec.150 <- nonpara.inx.misspec.150 <- 
  LS.inx.misspec.150 <- LSLW.inx.misspec.150 <- 
  HD.inx.misspec.150 <- trueHD.inx.misspec.150 <- NULL  
#shapes <- c(0.5, 0.75, 1, 2, 5, 7, 10, 12, 15, 20, 25, 
#  30, 40, 50, 60, 70, 80, 90, 100)
shapes <- c(0.75, 1, 2, 5, 7, 10, 12, 15, 20, 25, 
  30, 40, 50, 60, 70, 80, 90, 100)
for(j in shapes ){
  internal.output <- eval(parse(text=paste("misspec.150.2", j, sep = ".")))
  k <- which(shapes == j)
  para.marginal.misspec.150[k] <- as.numeric(internal.output[1, 1])
  para.local.misspec.150[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[2:3, 1])
  para.inx.misspec.150[c((25*(k-1)+1):(25*k))] <- as.numeric(internal.output[4:28, 1])
  para.error.misspec.150[k] <- as.numeric(internal.output[29, 1]) 
  para.area.misspec.150[k] <- as.numeric(internal.output[30, 1])
  nonpara.marginal.misspec.150[k] <- as.numeric(internal.output[31, 1])
  nonpara.local.misspec.150[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[32:33, 1])
  nonpara.inx.misspec.150[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[34:58, 1])
  nonpara.error.misspec.150[k] <- as.numeric(internal.output[59, 1]) 
  nonpara.area.misspec.150[k] <- as.numeric(internal.output[60, 1])
  LS.marginal.misspec.150[k] <- as.numeric(internal.output[61, 1])  
  LS.local.misspec.150[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[62:63, 1])
  LS.inx.misspec.150[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[64:88, 1])
  LS.error.misspec.150[k] <- as.numeric(internal.output[89, 1]) 
  LS.area.misspec.150[k] <- as.numeric(internal.output[90, 1])
  LSLW.marginal.misspec.150[k] <- as.numeric(internal.output[91, 1])  
  LSLW.local.misspec.150[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[92:93, 1])
  LSLW.inx.misspec.150[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[94:118, 1])
  LSLW.error.misspec.150[k] <- as.numeric(internal.output[119, 1]) 
  LSLW.area.misspec.150[k] <- as.numeric(internal.output[120, 1])
  HD.marginal.misspec.150[k] <- as.numeric(internal.output[121, 1])
  HD.local.misspec.150[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[122:123, 1])
  HD.inx.misspec.150[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[124:148, 1])
  HD.error.misspec.150[k] <- as.numeric(internal.output[149, 1]) 
  HD.area.misspec.150[k] <- as.numeric(internal.output[150, 1])
  trueHD.marginal.misspec.150[k] <- as.numeric(internal.output[151, 1])
  trueHD.local.misspec.150[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[152:153, 1])
  trueHD.inx.misspec.150[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[154:178, 1])
  trueHD.error.misspec.150[k] <- as.numeric(internal.output[179, 1]) 
  trueHD.area.misspec.150[k] <- as.numeric(internal.output[180, 1])        
}
@


%% n = 250
The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $5$. 

<<misspec.250.3.5, cache = TRUE>>=
set.seed(13)
n <- 250
bins <- 3
system.time(out.misspec.250.3.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 5))
})))
@

<<>>=
misspec.250.3.5 <- cbind( 
  rowMeans(out.misspec.250.3.5, na.rm = TRUE),  
  apply(out.misspec.250.3.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $20$.

<<misspec.250.3.20, cache = TRUE>>=
system.time(out.misspec.250.3.20 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 20))
})))
@

<<>>=
misspec.250.3.20 <- cbind( 
  rowMeans(out.misspec.250.3.20, na.rm = TRUE),  
  apply(out.misspec.250.3.20, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $40$.

<<misspec.250.3.40, cache = TRUE>>=
system.time(out.misspec.250.3.40 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 40))
})))
@

<<>>=
misspec.250.3.40 <- cbind( 
  rowMeans(out.misspec.250.3.40, na.rm = TRUE),  
  apply(out.misspec.250.3.40, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $60$.

<<misspec.250.3.60, cache = TRUE>>=
system.time(out.misspec.250.3.60 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 60))
})))
@

<<>>=
misspec.250.3.60 <- cbind( 
  rowMeans(out.misspec.250.3.60, na.rm = TRUE),  
  apply(out.misspec.250.3.60, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $80$.

<<misspec.250.3.80, cache = TRUE>>=
system.time(out.misspec.250.3.80 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 80))
})))
@

<<>>=
misspec.250.3.80 <- cbind( 
  rowMeans(out.misspec.250.3.80, na.rm = TRUE),  
  apply(out.misspec.250.3.80, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 250$ and shape = $100$.

<<misspec.250.3.100, cache = TRUE>>=
system.time(out.misspec.250.3.100 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 100))
})))
@

<<>>=
misspec.250.3.100 <- cbind( 
  rowMeans(out.misspec.250.3.100, na.rm = TRUE),  
  apply(out.misspec.250.3.100, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

Reorganize the output.

<<>>=
para.area.misspec.250 <- nonpara.area.misspec.250 <- 
  LS.area.misspec.250 <- LSLW.area.misspec.250 <- 
  HD.area.misspec.250 <- NULL
para.error.misspec.250 <- nonpara.error.misspec.250 <- 
  LS.error.misspec.250 <- LSLW.error.misspec.250 <- 
  HD.error.misspec.250 <- NULL
para.marginal.misspec.250 <- nonpara.marginal.misspec.250 <- 
  LS.marginal.misspec.250 <- LSLW.marginal.misspec.250 <- 
  HD.marginal.misspec.250 <- NULL
para.local.misspec.250 <- nonpara.local.misspec.250 <- 
  LS.local.misspec.250 <- LSLW.local.misspec.250 <- 
  HD.local.misspec.250 <- NULL
para.inx.misspec.250 <- nonpara.inx.misspec.250 <- 
  LS.inx.misspec.250 <- LSLW.inx.misspec.250 <- 
  HD.inx.misspec.250 <- NULL  
shapes <- c(5, 20, 40, 60, 80, 100)
for(j in shapes ){
  internal.output <- eval(parse(text=paste("misspec.250.3", j, sep = ".")))
  k <- which(shapes == j)
  para.marginal.misspec.250[k] <- as.numeric(internal.output[1, 1])
  para.local.misspec.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[2:4, 1])
  para.inx.misspec.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[5:29, 1])
  para.error.misspec.250[k] <- as.numeric(internal.output[30, 1]) 
  para.area.misspec.250[k] <- as.numeric(internal.output[31, 1])
  nonpara.marginal.misspec.250[k] <- as.numeric(internal.output[32, 1])
  nonpara.local.misspec.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[33:35, 1])
  nonpara.inx.misspec.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[36:60, 1])
  nonpara.error.misspec.250[k] <- as.numeric(internal.output[61, 1]) 
  nonpara.area.misspec.250[k] <- as.numeric(internal.output[62, 1])
  LS.marginal.misspec.250[k] <- as.numeric(internal.output[63, 1])  
  LS.local.misspec.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[64:66, 1])
  LS.inx.misspec.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[67:91, 1])
  LS.error.misspec.250[k] <- as.numeric(internal.output[92, 1]) 
  LS.area.misspec.250[k] <- as.numeric(internal.output[93, 1])
  LSLW.marginal.misspec.250[k] <- as.numeric(internal.output[94, 1])  
  LSLW.local.misspec.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[95:97, 1])
  LSLW.inx.misspec.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[98:122, 1])
  LSLW.error.misspec.250[k] <- as.numeric(internal.output[123, 1]) 
  LSLW.area.misspec.250[k] <- as.numeric(internal.output[124, 1])
  HD.marginal.misspec.250[k] <- as.numeric(internal.output[125, 1])
  HD.local.misspec.250[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[126:128, 1])
  HD.inx.misspec.250[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[129:153, 1])
  HD.error.misspec.250[k] <- as.numeric(internal.output[154, 1]) 
  HD.area.misspec.250[k] <- as.numeric(internal.output[155, 1])      
}
@


%% n = 500
The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $5$. 

<<misspec.500.3.5, cache = TRUE>>=
set.seed(13)
n <- 500
bins <- 3
system.time(out.misspec.500.3.5 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 5))
})))
@

<<>>=
misspec.500.3.5 <- cbind( 
  rowMeans(out.misspec.500.3.5, na.rm = TRUE),  
  apply(out.misspec.500.3.5, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $20$.

<<misspec.500.3.20, cache = TRUE>>=
system.time(out.misspec.500.3.20 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 20))
})))
@

<<>>=
misspec.500.3.20 <- cbind( 
  rowMeans(out.misspec.500.3.20, na.rm = TRUE),  
  apply(out.misspec.500.3.20, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $40$.

<<misspec.500.3.40, cache = TRUE>>=
system.time(out.misspec.500.3.40 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 40))
})))
@

<<>>=
misspec.500.3.40 <- cbind( 
  rowMeans(out.misspec.500.3.40, na.rm = TRUE),  
  apply(out.misspec.500.3.40, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $60$.

<<misspec.500.3.60, cache = TRUE>>=
system.time(out.misspec.500.3.60 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 60))
})))
@

<<>>=
misspec.500.3.60 <- cbind( 
  rowMeans(out.misspec.500.3.60, na.rm = TRUE),  
  apply(out.misspec.500.3.60, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $80$.

<<misspec.500.3.80, cache = TRUE>>=
system.time(out.misspec.500.3.80 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 80))
})))
@

<<>>=
misspec.500.3.80 <- cbind( 
  rowMeans(out.misspec.500.3.80, na.rm = TRUE),  
  apply(out.misspec.500.3.80, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$ and shape = $100$.

<<misspec.500.3.100, cache = TRUE>>=
system.time(out.misspec.500.3.100 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(misspec.simulator(beta = beta, n = n, 
      bins = bins, shape = 100))
})))
@

<<>>=
misspec.500.3.100 <- cbind( 
  rowMeans(out.misspec.500.3.100, na.rm = TRUE),  
  apply(out.misspec.500.3.100, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

Reorganize the output.

<<>>=
para.area.misspec.500 <- nonpara.area.misspec.500 <- 
  LS.area.misspec.500 <- LSLW.area.misspec.500 <- 
  HD.area.misspec.500 <- NULL
para.error.misspec.500 <- nonpara.error.misspec.500 <- 
  LS.error.misspec.500 <- LSLW.error.misspec.500 <- 
  HD.error.misspec.500 <- NULL
para.marginal.misspec.500 <- nonpara.marginal.misspec.500 <- 
  LS.marginal.misspec.500 <- LSLW.marginal.misspec.500 <- 
  HD.marginal.misspec.500 <- NULL
para.local.misspec.500 <- nonpara.local.misspec.500 <- 
  LS.local.misspec.500 <- LSLW.local.misspec.500 <- 
  HD.local.misspec.500 <- NULL
para.inx.misspec.500 <- nonpara.inx.misspec.500 <- 
  LS.inx.misspec.500 <- LSLW.inx.misspec.500 <- 
  HD.inx.misspec.500 <- NULL  
shapes <- c(5, 20, 40, 60, 80, 100)
for(j in shapes ){
  internal.output <- eval(parse(text=paste("misspec.500.3", j, sep = ".")))
  k <- which(shapes == j)
  para.marginal.misspec.500[k] <- as.numeric(internal.output[1, 1])
  para.local.misspec.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[2:4, 1])
  para.inx.misspec.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[5:29, 1])
  para.error.misspec.500[k] <- as.numeric(internal.output[30, 1]) 
  para.area.misspec.500[k] <- as.numeric(internal.output[31, 1])
  nonpara.marginal.misspec.500[k] <- as.numeric(internal.output[32, 1])
  nonpara.local.misspec.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[33:35, 1])
  nonpara.inx.misspec.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[36:60, 1])
  nonpara.error.misspec.500[k] <- as.numeric(internal.output[61, 1]) 
  nonpara.area.misspec.500[k] <- as.numeric(internal.output[62, 1])
  LS.marginal.misspec.500[k] <- as.numeric(internal.output[63, 1])  
  LS.local.misspec.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[64:66, 1])
  LS.inx.misspec.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[67:91, 1])
  LS.error.misspec.500[k] <- as.numeric(internal.output[92, 1]) 
  LS.area.misspec.500[k] <- as.numeric(internal.output[93, 1])
  LSLW.marginal.misspec.500[k] <- as.numeric(internal.output[94, 1])  
  LSLW.local.misspec.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[95:97, 1])
  LSLW.inx.misspec.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[98:122, 1])
  LSLW.error.misspec.500[k] <- as.numeric(internal.output[123, 1]) 
  LSLW.area.misspec.500[k] <- as.numeric(internal.output[124, 1])
  HD.marginal.misspec.500[k] <- as.numeric(internal.output[125, 1])
  HD.local.misspec.500[c((bins*(k-1)+1):(bins*k))] <- 
    as.numeric(internal.output[126:128, 1])
  HD.inx.misspec.500[c((25*(k-1)+1):(25*k))] <- 
    as.numeric(internal.output[129:153, 1])
  HD.error.misspec.500[k] <- as.numeric(internal.output[154, 1]) 
  HD.area.misspec.500[k] <- as.numeric(internal.output[155, 1])      
}
@


\newpage
\subsection{Results}
\label{sec:misspec-Results}

Results form our simulations are depicted in 
Figures~\ref{Fig:misspec.150}-\ref{Fig:misspec.inx.500}.  
For all five prediction regions we depict the estimatated area, prediction 
error, and local coverage probabilities with respect to binning in 
Figures~\ref{Fig:misspec.150}, \ref{Fig:misspec.250}, and 
\ref{Fig:misspec.500} for $n = 150$, $250$, and $500$ respectively.  For all 
five prediction regions we depict the local coverage probabilities across $x$ 
in Figures~\ref{Fig:misspec.inx.150}, \ref{Fig:misspec.inx.250}, and 
\ref{Fig:misspec.inx.500} for $n = 150$, $250$, and $500$ respectively.

In these simulations, we expect for the LSLW conformal prediction region to 
perform well.  The model misspecification is modest, the Gamma data  
appears to be almost symmetric, albeit heterogenous, about a cubic mean 
function.  From these simulations we see that the parametric conformal 
prediction region is similar to the LSLW prediciton region in area and 
prediction error.  Both the parametric and LSLW conformal 
prediction regions possess finite-sample, albeit slightly conservative, 
local validity with respect to binning and they both give almost nominal 
finite-sample conditional validity across the support.
Moreover, these prediciton regions visually fit the data well as seen in 
Section~\ref{sec:misspecplots}.
The nonparametric conformal prediction region gives closer to nominal 
coverage than both the parametric and LSLW conformal prediction regions, 
and it possesses finite-sample local validity with respect to 
binning.  However, this prediction region is larger, gives higher 
prediciton error than the parametric and LSLW conformal prediction 
regions, and does not visually fit the data well for most simulation settings 
as seen in Section~\ref{sec:misspecplots}.  The misspecified HD and LS 
conformal prediction regions  provide extreme undercoverage at small values 
of $x$ and extreme overcoverage at large values of $x$.  These prediction 
regions are also larger, they give higher prediciton error than the 
parametric and LSLW conformal prediction regions, and the LS conformal 
prediction region does not visually fit the data well for most simulation 
settings as seen in Section~\ref{sec:misspecplots}. 



% Diagnostics, n = 150
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-misspec-150, echo = FALSE>>=
par(mfrow = c(2,2), oma = c(4,4,2,0), mar = c(1,1,1,2))
shapes <- c(0.75, 1, 2, 5, 7, 10, 12, 15, 20, 25, 
  30, 40, 50, 60, 70, 80, 90, 100)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), ylim = c(-0.05, 0.50))
lines(log(shapes), para.area.misspec.150, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.area.misspec.150, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.area.misspec.150, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.area.misspec.150, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.area.misspec.150, col = "blue", lty = 4, lwd = 1.5)
lines(log(shapes), trueHD.area.misspec.150, col = "orange", lty = 1, lwd = 1.5)
axis(2)
mtext("area", side = 2, cex = 1.25, line = 2)

legend(0, 0.50, legend=c("misspecified parametric", 
  "nonparametric", "LSLW", "LS", "misspecified HD", "true HD", 
  "nominal coverage"), 
  col=c("red", "green", "purple", "black", "blue", "orange", "grey"), 
  cex = 1.25, lty=c(1,2,1,2,4,1,1), bty = "n")

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.90, 3.50))
lines(log(shapes), para.error.misspec.150, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.error.misspec.150, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.error.misspec.150, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.error.misspec.150, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.error.misspec.150, col = "blue", lty = 4, lwd = 1.5)
lines(log(shapes), trueHD.error.misspec.150, col = "orange", lty = 1, lwd = 1.5)
axis(2)
mtext("prediction error", side = 2, cex = 1.25, line = 2)

s <- length(shapes)
plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.80, 1.00))
lines(log(shapes), para.local.misspec.150[2*(1:s) - 1], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.150[2*(1:s) - 1], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.150[2*(1:s) - 1], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.150[2*(1:s) - 1], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.150[2*(1:s) - 1], col = "blue", lty = 4, lwd = 1.5)
lines(log(shapes), trueHD.local.misspec.150[2*(1:s) - 1], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 0 < x < 1/2", side = 2, cex = 1.25, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.80, 1.00))
lines(log(shapes), para.local.misspec.150[2*(1:s)], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.150[2*(1:s)], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.150[2*(1:s)], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.150[2*(1:s)], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.150[2*(1:s)], col = "blue", lty = 4, lwd = 1.5)
lines(log(shapes), trueHD.local.misspec.150[2*(1:s)], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 1/2 <= x < 1", side = 2, cex = 1.25, line = 2)

mtext("log(shape)", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("Simulation Setting B", side = 3, cex = 1.25, line = 0.5, outer = TRUE)
@
\end{center}
\caption{This figure compares the performance of the 
  misspecified parametric,
  nonparametric,
  least squares, and 
  least squares locally weighted conformal prediciton region and the 
  misspecified and correctly specified highest density prediction region 
  when $n = 150$ and the number of bins equals 2.  
  The specific diagnostics used to compare these prediciton regions is the 
    area (top-left panel),
    prediction error (top-right panel), and
    the coverage probability with respect to binning (bottom row) 
    across shape parameter values.
  The average of 250 Monte Carlo samples at each shape parameter value in 
  these simulation settings form the lines that are depicted in this figure.}
\label{Fig:misspec.150}
\end{figure}



% local coverage, n = 150
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-misspec-inx-150, echo = FALSE>>=
par(mfrow = c(4,4), oma = c(4,4,1,0), mar = c(1,3,3,0))
inx <- 0.02 + 0:24 * 0.04

# shape = 0.75
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[1:25], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[1:25], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[1:25], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[1:25], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[1:25], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[1:25], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 0.75", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.90, 1))
legend(-0.20, 1.01, legend=c("misspecified parametric", 
  "nonparametric", "LSLW", "LS", "misspecified HD", "true HD", 
  "nominal coverage"), 
  col=c("red", "green", "purple", "black", "blue", "orange", "grey"), cex = 0.90,
  lty=c(1,2,1,2,4,1,1), bty = "n")

# shape = 1
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[26:50], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[26:50], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[26:50], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[26:50], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[26:50], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[26:50], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 1", side = 3, cex = 1, line = 2)

# shape = 2
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[51:75], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[51:75], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[51:75], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[51:75], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[51:75], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[51:75], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 2", side = 3, cex = 1, line = 2)

# shape = 5
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[76:100], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[76:100], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[76:100], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[76:100], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[76:100], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[76:100], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 5", side = 3, cex = 1, line = 2)

# shape = 7
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[101:125], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[101:125], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[101:125], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[101:125], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[101:125], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[101:125], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 7", side = 3, cex = 1, line = 2)

# shape = 10
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[126:150], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[126:150], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[126:150], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[126:150], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[126:150], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[126:150], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 10", side = 3, cex = 1, line = 2)

# shape = 12
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[151:175], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[151:175], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[151:175], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[151:175], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[151:175], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[151:175], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 12", side = 3, cex = 1, line = 2)

# shape = 15
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[176:200], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[176:200], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[176:200], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[176:200], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[176:200], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[176:200], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 15", side = 3, cex = 1, line = 2)

# shape = 20
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[201:225], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[201:225], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[201:225], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[201:225], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[201:225], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[201:225], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 20", side = 3, cex = 1, line = 2)

# shape = 25
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[226:250], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[226:250], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[226:250], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[226:250], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[226:250], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[226:250], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 25", side = 3, cex = 1, line = 2)

# shape = 30
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[251:275], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[251:275], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[251:275], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[251:275], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[251:275], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[251:275], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 30", side = 3, cex = 1, line = 2)

# shape = 40
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[276:300], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[276:300], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[276:300], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[276:300], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[276:300], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[276:300], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("shape = 40", side = 3, cex = 1, line = 2)

# shape = 50
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[301:325], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[301:325], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[301:325], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[301:325], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[301:325], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[301:325], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 50", side = 3, cex = 1, line = 2)

# shape = 60
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[326:350], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[326:350], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[326:350], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[326:350], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[326:350], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[326:350], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 60", side = 3, cex = 1, line = 2)

# shape = 70
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.150[351:375], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.150[351:375], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.150[351:375], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.150[351:375], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.150[351:375], col = "blue", lty = 4, lwd = 1.5)
lines(inx, trueHD.inx.misspec.150[351:375], col = "orange", lty = 1, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 70", side = 3, cex = 1, line = 2)

mtext("x", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("coverage", side = 2, cex = 1.25, line = 0, outer = TRUE)
@
\end{center}
\caption{Plot of the estimated coverage probabilities of prediction regions 
  across $x$ and shape parameter values when the model is misspecified, 
  $n = 150$, and the number of bins is equal to $2$.}
\label{Fig:misspec.inx.150}
\end{figure}


% Diagnostics, n = 250
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-misspec-250, echo = FALSE>>=
par(mfrow = c(3,2), oma = c(4,4,2,0), mar = c(1,1,1,2))
shapes <- c(5, 20, 40, 60, 80, 100)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), ylim = c(0, 0.08))
lines(log(shapes), para.area.misspec.250, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.area.misspec.250, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.area.misspec.250, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.area.misspec.250, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.area.misspec.250, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("area", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.50, 3.00))
lines(log(shapes), para.error.misspec.250, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.error.misspec.250, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.error.misspec.250, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.error.misspec.250, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.error.misspec.250, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("prediction error", side = 2, cex = 1, line = 2)

s <- length(shapes)
plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.78, 1.00))
lines(log(shapes), para.local.misspec.250[3*(1:s) - 2], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.250[3*(1:s) - 2], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.250[3*(1:s) - 2], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.250[3*(1:s) - 2], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.250[3*(1:s) - 2], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 0 < x < 1/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.78, 1.00))
lines(log(shapes), para.local.misspec.250[3*(1:s) - 1], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.250[3*(1:s) - 1], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.250[3*(1:s) - 1], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.250[3*(1:s) - 1], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.250[3*(1:s) - 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 1/3 <= x < 2/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.78, 1.00))
lines(log(shapes), para.local.misspec.250[3*(1:s)], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.250[3*(1:s)], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.250[3*(1:s)], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.250[3*(1:s)], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.250[3*(1:s)], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 2/3 <= x < 1", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.90, 0.98))
legend(0, 0.96, legend=c("misspecified parametric", 
  "nonparametric", "LSLW", "LS", "misspecified HD", "nominal coverage"), 
  col=c("red", "green", "purple", "black", "blue", "grey"), 
  cex = 1.25, lty=c(1,2,1,2,4,1), bty = "n")

mtext("log(shape)", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("Simulation Setting B", side = 3, cex = 1.25, line = 0.5, outer = TRUE)
@
\end{center}
\caption{This figure compares the performance of the 
  misspecified parametric,
  nonparametric,
  least squares, and 
  least squares locally weighted conformal prediciton region and the 
  misspecified highest density prediction region when $n = 250$ and the 
  number of bins equals 3.  
  The specific diagnostics used to compare these prediciton regions is the 
    area (top-left panel),
    prediction error (top-right panel), and
    the coverage probability with respect to binning (bottom row) 
    across shape parameter values.
  The average of 50 Monte Carlo samples at each shape parameter value in 
  these simulation settings form the lines that are depicted in this figure.}
\label{Fig:misspec.250}
\end{figure}



% local coverage, n = 250
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-misspec-inx-250, echo = FALSE>>=
par(mfrow = c(4,2), oma = c(4,4,1,0), mar = c(1,3,3,0))

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.250[1:25], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.250[1:25], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.250[1:25], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.250[1:25], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.250[1:25], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 5", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.90, 0.98))
legend(0, 0.98, legend=c("misspecified parametric", 
  "nonparametric", "LSLW", "LS", "misspecified HD", "nominal coverage"), 
  col=c("red", "green", "purple", "black", "blue", "grey"), 
  cex = 1, 
  lty=c(1,2,1,2,4,1), bty = "n")

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.250[26:50], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.250[26:50], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.250[26:50], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.250[26:50], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.250[26:50], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 20", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.250[51:75], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.250[51:75], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.250[51:75], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.250[51:75], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.250[51:75], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 40", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.250[76:100], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.250[76:100], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.250[76:100], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.250[76:100], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.250[76:100], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 60", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.250[101:125], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.250[101:125], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.250[101:125], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.250[101:125], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.250[101:125], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 80", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.250[126:150], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.250[126:150], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.250[126:150], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.250[126:150], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.250[126:150], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("shape = 100", side = 3, cex = 1, line = 2)

mtext("x", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("coverage", side = 2, cex = 1.25, line = 0, outer = TRUE)
@
\end{center}
\caption{Plot of the estimated coverage probabilities of prediction regions 
  across $x$ and shape parameter values when the model is misspecified, 
  $n = 250$, and the number of bins is equal to $3$.}
\label{Fig:misspec.inx.250}
\end{figure}



% Diagnostics, n = 500
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-misspec-500, echo = FALSE>>=
par(mfrow = c(3,2), oma = c(4,4,2,0), mar = c(1,1,1,2))
shapes <- c(5, 20, 40, 60, 80, 100)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), ylim = c(0, 0.08))
lines(log(shapes), para.area.misspec.500, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.area.misspec.500, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.area.misspec.500, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.area.misspec.500, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.area.misspec.500, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("area", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.50, 3.00))
lines(log(shapes), para.error.misspec.500, col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.error.misspec.500, col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.error.misspec.500, col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.error.misspec.500, col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.error.misspec.500, col = "blue", lty = 4, lwd = 1.5)
axis(2)
mtext("prediction error", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.78, 1.00))
lines(log(shapes), para.local.misspec.500[3*(1:s) - 2], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.500[3*(1:s) - 2], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.500[3*(1:s) - 2], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.500[3*(1:s) - 2], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.500[3*(1:s) - 2], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 0 <= x < 1/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.78, 1.00))
lines(log(shapes), para.local.misspec.500[3*(1:s) - 1], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.500[3*(1:s) - 1], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.500[3*(1:s) - 1], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.500[3*(1:s) - 1], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.500[3*(1:s) - 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 1/3 <= x < 2/3", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(log(min(shapes)), log(max(shapes))), 
  ylim = c(0.78, 1.00))
lines(log(shapes), para.local.misspec.500[3*(1:s)], col = "red", lty = 1, lwd = 1.5)
lines(log(shapes), nonpara.local.misspec.500[3*(1:s)], col = "green", lty = 2, lwd = 1.5)
lines(log(shapes), LSLW.local.misspec.500[3*(1:s)], col = "purple", lty = 1, lwd = 1.5)
lines(log(shapes), LS.local.misspec.500[3*(1:s)], col = "black", lty = 2, lwd = 1.5)
lines(log(shapes), HD.local.misspec.500[3*(1:s)], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("coverage when 2/3 <= x < 1", side = 2, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.90, 0.98))
legend(0, 0.96, legend=c("misspecified parametric", 
  "nonparametric", "LSLW", "LS", "misspecified HD", "nominal coverage"), 
  col=c("red", "green", "purple", "black", "blue", "grey"), 
  cex = 1.25, lty=c(1,2,1,2,4,1), bty = "n")

mtext("log(shape)", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("Simulation Setting B", side = 3, cex = 1.25, line = 0.5, outer = TRUE)
@
\end{center}
\caption{This figure compares the performance of the 
  misspecified parametric,
  nonparametric,
  least squares, and 
  least squares locally weighted conformal prediciton region and the 
  misspecified highest density prediction region when $n = 500$ and the 
  number of bins equals 3.  
  The specific diagnostics used to compare these prediciton regions is the 
    area (top-left panel),
    prediction error (top-right panel), and
    the coverage probability with respect to binning (bottom row) 
    across shape parameter values.
  The average of 50 Monte Carlo samples at each shape parameter value in 
  these simulation settings form the lines that are depicted in this figure.}
\label{Fig:misspec.500}
\end{figure}



% local coverage, n = 500
\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-misspec-inx-500, echo = FALSE>>=
par(mfrow = c(4,2), oma = c(4,4,1,0), mar = c(1,3,3,0))

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.500[1:25], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.500[1:25], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.500[1:25], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.500[1:25], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.500[1:25], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 5", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.80, 0.98))
legend(0, 0.98, legend=c("misspecified parametric", 
  "nonparametric", "LSLW", "LS", "misspecified HD", "nominal coverage"), 
  col=c("red", "green", "purple", "black", "blue", "grey"), 
  cex = 1, lty=c(1,2,1,2,4,1), bty = "n")

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.500[26:50], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.500[26:50], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.500[26:50], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.500[26:50], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.500[26:50], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 20", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.500[51:75], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.500[51:75], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.500[51:75], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.500[51:75], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.500[51:75], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
mtext("shape = 40", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.500[76:100], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.500[76:100], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.500[76:100], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.500[76:100], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.500[76:100], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(2)
mtext("shape = 60", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.500[101:125], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.500[101:125], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.500[101:125], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.500[101:125], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.500[101:125], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("shape = 80", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.25, 1.00))
lines(inx, para.inx.misspec.500[126:150], col = "red", lty = 1, lwd = 1.5)
lines(inx, nonpara.inx.misspec.500[126:150], col = "green", lty = 2, lwd = 1.5)
lines(inx, LSLW.inx.misspec.500[126:150], col = "purple", lty = 1, lwd = 1.5)
lines(inx, LS.inx.misspec.500[126:150], col = "black", lty = 2, lwd = 1.5)
lines(inx, HD.inx.misspec.500[126:150], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("shape = 100", side = 3, cex = 1, line = 2)

mtext("x", side = 1, cex = 1.25, line = 2, outer = TRUE)
mtext("coverage", side = 2, cex = 1.25, line = 0, outer = TRUE)
@
\end{center}
\caption{Plot of the estimated coverage probabilities of prediction regions 
  across $x$ and shape parameter values when the model is misspecified, 
  $n = 500$, and the number of bins is equal to $3$.}
\label{Fig:misspec.inx.500}
\end{figure}





\newpage
\section{Linear Regression Simulations}
\label{sec:regression}

In this Section, we compare the parametric conformal prediction 
region, the nonparametric conformal prediction region, the LSLW conformal 
prediction region, the LS conformal prediction region, and the HD prediction 
region for linear regression models with normal errors and constant variance.  
We specify that $\beta = (2, 5)^T$ and the standard deviation of the errors 
about the mean function as $\sigma = 1$.
We consider sample sizes of $n \in \{150, 250, 500\}$. 
When $n = 150$ we build the parametric and nonparametric conformal prediction 
regions using 2 bins.  When $n = 250, 500$ we build the parametric and 
nonparametric conformal prediction regions using 3 bins.  These number of bin 
choices correspond to the bin width asymptotics of \citet{lei2014distribution}. 


\subsection{Simulations}

The following function computes our diagnostic measures for the five 
prediction regions under investigation in the univariate case where data 
is generated from a Gaussian regression model, i.e. 
$Y \sim N(X'\beta, \sigma^2)$ and $X \sim U(0,1)$.

<<>>=
regression.simulator <- function(n = 500, alpha = 0.10, beta, 
  bins = 3, sd = 1, parametric = TRUE, nonparametric = TRUE, 
  LS = TRUE, LSLW = TRUE, HD = TRUE, cores = 6){

  p <- d <- length(beta) - 1
  x <- matrix(runif(n), ncol = p)
  y <- rep(0,n)
  data <- NULL

  ## set up partition
  if(class(bins) == "NULL"){ 
    wn <- min(1/ floor(1 / (log(n)/n)^(1/(d+3))), 1/2)
    bins <- 1 / wn
  }

  ## generate the data 
  mu <- cbind(1, x) %*% beta
  y <- rnorm(n = n, mean = mu, sd = sd)
  data <- data.frame(y = y, x = x)
  colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

  ## fit the linear regression model
  fit <- glm(y ~ x1, family = "gaussian", data = data)
  paraCI <- nonparaCI <- LSCI <- LSLWCI <- HDCI <- NULL
  formula <- fit$formula
  newdata <- data
  respname <- all.vars(formula)[1]
  newdata <- newdata[, !(colnames(data) %in% respname)]
  newdata <- as.matrix(newdata)

  ## obtain the prediction regions
  if(parametric){ 
    cpred <- conformal.glm(fit, parametric = TRUE, 
      nonparametric = FALSE, alpha = alpha,
      bins = bins, cores = cores)
    paraCI <- cpred$paraconformal
  }
  if(nonparametric){ 
    cpred <- conformal.glm(fit, parametric = FALSE, 
      nonparametric = TRUE, alpha = alpha,
      bins = bins, cores = cores)
    nonparaCI <- cpred$nonparaconformal
  }
  if(LS){
    p1.tibs <- conformal.pred(x = x, y = y, x0 = x, 
      train.fun = train.fun, predict.fun = predict.fun, 
      alpha = alpha)
    LSCI <- cbind(p1.tibs$lo, p1.tibs$up)
  }
  if(LSLW){
    regression.model <- lm(y ~ x)
    abs.resid <- abs(regression.model$resid)
    smooth.call <- smooth.spline(x, abs.resid, 
      nknots = 10)
    lambda <- smooth.call$lambda
    df <- smooth.call$df
    mad.train.fun <- function(x, y, out = NULL){
      smooth.spline(x[, 1], y, lambda = lambda, 
      df = df, nknots = 10)
    }
    p2.tibs <- conformal.pred(x = x, y = y, x0 = x, 
      train.fun = train.fun, predict.fun = predict.fun, 
      mad.train.fun = mad.train.fun,
      mad.predict.fun = mad.predict.fun,
      alpha = alpha)
    LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)
  }
  if(HD){
    fit = lm(y ~ x, data = data)
    betaMLE <- coefficients(fit)
    sdMLE <- summary(fit)$sigma
    meanMLE <- as.numeric(cbind(1, x) %*% betaMLE)
    HDCI <- do.call(rbind, lapply(1:nrow(newdata), function(j){ 
      hdi(qnorm, 1 - alpha, sd = sdMLE, mean = meanMLE[j])
    }))
  }
    
  ## local coverage prediction regions
  output.parametric <- output.nonparametric <- 
    output.LS <- output.LSLW <- output.HD <- rep(NA, bins + 1)
  if(parametric){
    marginal.parametric <- local.coverage(region = paraCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")  
    local.parametric <- local.coverage(region = paraCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.parametric <- local.coverage(region = paraCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.parametric <- c(marginal.parametric, local.parametric, 
      local.inx.parametric, 
      mean(apply(paraCI, 1, diff)), 
      absolute.error(y = y, region = paraCI))
  }
  if(nonparametric){
    marginal.nonparametric <- local.coverage(region = nonparaCI, 
      nonparametric = "TRUE", data = data, d = p, bins = 1, 
      at.data = "TRUE")
    local.nonparametric <- local.coverage(region = nonparaCI, 
      nonparametric = "TRUE", data = data, d = p, bins = bins, 
      at.data = "TRUE")
    local.inx.nonparametric <- local.coverage(region = nonparaCI, 
      nonparametric = "TRUE", data = data, d = p, bins = 25, 
      at.data = "TRUE")
    output.nonparametric <- 
      c(marginal.nonparametric, local.nonparametric, 
        local.inx.nonparametric, 
        area.nonparametric(nonparaCI),
        absolute.error.nonparametric(data = data, 
          region = nonparaCI))
  }
  if(LS){
    marginal.LS <- local.coverage(region = LSCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")
    local.LS <- local.coverage(region = LSCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.LS <- local.coverage(region = LSCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.LS <- c(marginal.LS, local.LS, local.inx.LS, 
      mean(apply(LSCI, 1, diff)), 
      absolute.error(y = y, region = LSCI))
  }
  if(LSLW){
    marginal.LSLW <- local.coverage(region = LSLWCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")
    local.LSLW <- local.coverage(region = LSLWCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.LSLW <- local.coverage(region = LSLWCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.LSLW <- c(marginal.LSLW, local.LSLW, local.inx.LSLW, 
      mean(apply(LSLWCI, 1, diff)), 
      absolute.error(y = y, region = LSLWCI))      
  }
  if(HD){
    marginal.HD <- local.coverage(region = HDCI, 
      data = data, d = p, bins = 1, at.data = "TRUE")
    local.HD <- local.coverage(region = HDCI, 
      data = data, d = p, bins = bins, at.data = "TRUE")
    local.inx.HD <- local.coverage(region = HDCI, 
      data = data, d = p, bins = 25, at.data = "TRUE")
    output.HD <- c(marginal.HD, local.HD, local.inx.HD, 
      mean(apply(HDCI, 1, diff)), 
      absolute.error(y = y, region = HDCI))
  }

  output <- list(output.parametric = output.parametric, 
    output.nonparametric = output.nonparametric,
    output.LS = output.LS, 
    output.LSLW = output.LSLW, 
    output.HD = output.HD)
  output

}
@


The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 150$.

<<regression.150.2, cache = TRUE>>=
set.seed(13)
beta <- c(2, 5)
n <- 150
bins <- 2
B <- 50
system.time(out.regression.150.2 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(regression.simulator(beta = beta, n = n, 
      bins = bins))
})))
@

<<>>=
regression.150.2 <- cbind( 
  rowMeans(out.regression.150.2, na.rm = TRUE),  
  apply(out.regression.150.2, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 150$.

<<regression.250.3, cache = TRUE>>=
n <- 250
bins <- 3
system.time(out.regression.250.3 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(regression.simulator(beta = beta, n = n, 
      bins = bins))
})))
@

<<>>=
regression.250.3 <- cbind( 
  rowMeans(out.regression.250.3, na.rm = TRUE),  
  apply(out.regression.250.3, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@

The following performs our Monte Carlo simulation of $B = 50$ iterations 
when $n = 500$.

<<regression.500.3, cache = TRUE>>=
n <- 500
system.time(out.regression.500.3 <- do.call(cbind, 
  lapply(1:B, FUN = function(j){
    unlist(regression.simulator(beta = beta, n = n, 
      bins = bins))
})))
@

<<>>=
regression.500.3 <- cbind( 
  rowMeans(out.regression.500.3, na.rm = TRUE),  
  apply(out.regression.500.3, 1, 
  FUN = function(x){ 
    sds <- sd(x, na.rm = TRUE)
    lengths <- length(which(!is.na(x)))
    sds / sqrt(lengths)
  }))
@



\subsection{Results}

Results form our simulations are depicted in 
Table~\ref{Tab:regression-results} and Figure~\ref{Fig:regresion.inx}.  
This table and figure depicts the estimatated area, prediction 
error, and local coverage probabilities for all five considered prediction 
regions. 

In these simulations, errors about the estimated mean function are symmetric 
and homogeneous across the support.  We therefore expect for the LS and LSLW 
conformal prediction regions to perform nearly as well as the oracle HD 
prediction region.  These prediction regions also exhibit finite-sample 
marginal validity, local validity with respect to binning, and near 
conditional validity across the support.  The parametric conformal prediction 
region is similar to the LS and LSLW conformal prediciton regions and the HD 
prediction region in area, prediction error, finite-sample coverage 
properties, and appearance.  However, the parametric conformal prediciton 
region is slightly larger and gives more conservative coverage that these 
other prediction regions.  The nonparametric conformal prediciton region 
is larger and gives larger prediciton errors than the other prediciton 
regions.  It also appears to not visually fit the data well while the others 
do as seen in Section~\ref{sec:regressionplots}.


<<echo = FALSE>>=
regression.150.2[, 1] <- round(regression.150.2[, 1], 3)
regression.250.3[, 1] <- round(regression.250.3[, 1], 3)
regression.500.3[, 1] <- round(regression.500.3[, 1], 3)
regression.150.2[, 2] <- round(regression.150.2[, 2], 4)
regression.250.3[, 2] <- round(regression.250.3[, 2], 4)
regression.500.3[, 2] <- round(regression.500.3[, 2], 4)
@


\begin{table}[h!]
\tiny
\begin{center}
\begin{tabular}{llccccc}
  & & parametric conformal & nonparametric conformal & LS conformal & 
    LSLW conformal & HD region \\ 
  $n = 150$
    & marginal coverage &
  $\Sexpr{regression.150.2[1, 1]} \; (\Sexpr{regression.150.2[1, 2]})$ & 
  $\Sexpr{regression.150.2[31, 1]} \; (\Sexpr{regression.150.2[31, 2]})$ & 
  $\Sexpr{regression.150.2[61, 1]} \; (\Sexpr{regression.150.2[61, 2]})$ & 
  $\Sexpr{regression.150.2[91, 1]}  (\Sexpr{regression.150.2[91, 2]})$ & 
  $\Sexpr{regression.150.2[121, 1]} \; (\Sexpr{regression.150.2[121, 2]})$ \\
    & local coverage when $0 < x < 1/2$ & 
  $\Sexpr{regression.150.2[2, 1]} \; (\Sexpr{regression.150.2[2, 2]})$ & 
  $\Sexpr{regression.150.2[32, 1]} \; (\Sexpr{regression.150.2[32, 2]})$ & 
  $\Sexpr{regression.150.2[62, 1]} \; (\Sexpr{regression.150.2[62, 2]})$ & 
  $\Sexpr{regression.150.2[92, 1]} \; (\Sexpr{regression.150.2[92, 2]})$ & 
  $\Sexpr{regression.150.2[122, 1]} \; (\Sexpr{regression.150.2[122, 2]})$ \\
    & local coverage when $1/2 \leq x < 1$ & 
  $\Sexpr{regression.150.2[3, 1]} \; (\Sexpr{regression.150.2[3, 2]})$ & 
  $\Sexpr{regression.150.2[33, 1]} \; (\Sexpr{regression.150.2[33, 2]})$ & 
  $\Sexpr{regression.150.2[63, 1]} \; (\Sexpr{regression.150.2[63, 2]})$ & 
  $\Sexpr{regression.150.2[93, 1]} \; (\Sexpr{regression.150.2[93, 2]})$ & 
  $\Sexpr{regression.150.2[123, 1]} \; (\Sexpr{regression.150.2[123, 2]})$ \\
    & area &
  $\Sexpr{regression.150.2[29, 1]} \; (\Sexpr{regression.150.2[29, 2]})$ & 
  $\Sexpr{regression.150.2[59, 1]} \; (\Sexpr{regression.150.2[59, 2]})$ & 
  $\Sexpr{regression.150.2[89, 1]} \; (\Sexpr{regression.150.2[89, 2]})$ & 
  $\Sexpr{regression.150.2[119, 1]} \; (\Sexpr{regression.150.2[119, 2]})$ & 
  $\Sexpr{regression.150.2[149, 1]} \; (\Sexpr{regression.150.2[149, 2]})$ \\
    & prediction error &
  $\Sexpr{regression.150.2[30, 1]} \; (\Sexpr{regression.150.2[30, 2]})$ & 
  $\Sexpr{regression.150.2[60, 1]} \; (\Sexpr{regression.150.2[60, 2]})$ & 
  $\Sexpr{regression.150.2[90, 1]} \; (\Sexpr{regression.150.2[90, 2]})$ & 
  $\Sexpr{regression.150.2[120, 1]} \; (\Sexpr{regression.150.2[120, 2]})$ & 
  $\Sexpr{regression.150.2[150, 1]} \; (\Sexpr{regression.150.2[150, 2]})$ \\
  \hline
  $n = 250$  
    & marginal coverage &
  $\Sexpr{regression.250.3[1, 1]} \; (\Sexpr{regression.250.3[1, 2]})$ & 
  $\Sexpr{regression.250.3[32, 1]} \; (\Sexpr{regression.250.3[32, 2]})$ & 
  $\Sexpr{regression.250.3[63, 1]} \; (\Sexpr{regression.250.3[63, 2]})$ & 
  $\Sexpr{regression.250.3[94, 1]} \; (\Sexpr{regression.250.3[94, 2]})$ & 
  $\Sexpr{regression.250.3[125, 1]} \; (\Sexpr{regression.250.3[125, 2]})$ \\
    & local coverage when $0 < x < 1/3$ & 
  $\Sexpr{regression.250.3[2, 1]} \; (\Sexpr{regression.250.3[2, 2]})$ & 
  $\Sexpr{regression.250.3[33, 1]} \; (\Sexpr{regression.250.3[33, 2]})$ & 
  $\Sexpr{regression.250.3[64, 1]} \; (\Sexpr{regression.250.3[64, 2]})$ & 
  $\Sexpr{regression.250.3[95, 1]} \; (\Sexpr{regression.250.3[95, 2]})$ & 
  $\Sexpr{regression.250.3[126, 1]} \; (\Sexpr{regression.250.3[126, 2]})$ \\
    & local coverage when $1/3 \leq x < 2/3$ & 
  $\Sexpr{regression.250.3[3, 1]} \; (\Sexpr{regression.250.3[3, 2]})$ & 
  $\Sexpr{regression.250.3[34, 1]} \; (\Sexpr{regression.250.3[34, 2]})$ & 
  $\Sexpr{regression.250.3[65, 1]} \; (\Sexpr{regression.250.3[65, 2]})$ & 
  $\Sexpr{regression.250.3[96, 1]} \; (\Sexpr{regression.250.3[96, 2]})$ & 
  $\Sexpr{regression.250.3[127, 1]} \; (\Sexpr{regression.250.3[127, 2]})$ \\
    & local coverage when $2/3 \leq x < 1$ &
  $\Sexpr{regression.250.3[4, 1]} \; (\Sexpr{regression.250.3[4, 2]})$ & 
  $\Sexpr{regression.250.3[35, 1]} \; (\Sexpr{regression.250.3[35, 2]})$ & 
  $\Sexpr{regression.250.3[66, 1]} \; (\Sexpr{regression.250.3[66, 2]})$ & 
  $\Sexpr{regression.250.3[97, 1]} \; (\Sexpr{regression.250.3[97, 2]})$ & 
  $\Sexpr{regression.250.3[128, 1]} \; (\Sexpr{regression.250.3[128, 2]})$ \\
    & area & 
  $\Sexpr{regression.250.3[30, 1]} \; (\Sexpr{regression.250.3[30, 2]})$ & 
  $\Sexpr{regression.250.3[61, 1]} \; (\Sexpr{regression.250.3[61, 2]})$ & 
  $\Sexpr{regression.250.3[92, 1]} \; (\Sexpr{regression.250.3[92, 2]})$ & 
  $\Sexpr{regression.250.3[123, 1]} \; (\Sexpr{regression.250.3[123, 2]})$ & 
  $\Sexpr{regression.250.3[154, 1]} \; (\Sexpr{regression.250.3[154, 2]})$ \\
    & prediction error & 
  $\Sexpr{regression.250.3[31, 1]} \; (\Sexpr{regression.250.3[31, 2]})$ & 
  $\Sexpr{regression.250.3[62, 1]} \; (\Sexpr{regression.250.3[62, 2]})$ & 
  $\Sexpr{regression.250.3[93, 1]} \; (\Sexpr{regression.250.3[93, 2]})$ & 
  $\Sexpr{regression.250.3[124, 1]} \; (\Sexpr{regression.250.3[124, 2]})$ & 
  $\Sexpr{regression.250.3[155, 1]} \; (\Sexpr{regression.250.3[155, 2]})$ \\
  \hline
  $n = 500$
    & marginal coverage & 
  $\Sexpr{regression.500.3[1, 1]} \; (\Sexpr{regression.500.3[1, 2]})$ & 
  $\Sexpr{regression.500.3[32, 1]} \; (\Sexpr{regression.500.3[32, 2]})$ & 
  $\Sexpr{regression.500.3[63, 1]} \; (\Sexpr{regression.500.3[63, 2]})$ & 
  $\Sexpr{regression.500.3[94, 1]} \; (\Sexpr{regression.500.3[94, 2]})$ & 
  $\Sexpr{regression.500.3[125, 1]} \; (\Sexpr{regression.500.3[125, 2]})$ \\
    & local coverage when $0 < x < 1/3$ & 
  $\Sexpr{regression.500.3[2, 1]} \; (\Sexpr{regression.500.3[2, 2]})$ & 
  $\Sexpr{regression.500.3[33, 1]} \; (\Sexpr{regression.500.3[33, 2]})$ & 
  $\Sexpr{regression.500.3[64, 1]} \; (\Sexpr{regression.500.3[64, 2]})$ & 
  $\Sexpr{regression.500.3[95, 1]} \; (\Sexpr{regression.500.3[95, 2]})$ & 
  $\Sexpr{regression.500.3[126, 1]} \; (\Sexpr{regression.500.3[126, 2]})$ \\
    & local coverage when $1/3 \leq x < 2/3$ & 
  $\Sexpr{regression.500.3[3, 1]} \; (\Sexpr{regression.500.3[3, 2]})$ & 
  $\Sexpr{regression.500.3[34, 1]} \; (\Sexpr{regression.500.3[34, 2]})$ & 
  $\Sexpr{regression.500.3[65, 1]} \; (\Sexpr{regression.500.3[65, 2]})$ & 
  $\Sexpr{regression.500.3[96, 1]} \; (\Sexpr{regression.500.3[96, 2]})$ & 
  $\Sexpr{regression.500.3[127, 1]} \; (\Sexpr{regression.500.3[127, 2]})$ \\
    & local coverage when $2/3 \leq x < 1$ & 
  $\Sexpr{regression.500.3[4, 1]} \; (\Sexpr{regression.500.3[4, 2]})$ & 
  $\Sexpr{regression.500.3[35, 1]} \; (\Sexpr{regression.500.3[35, 2]})$ & 
  $\Sexpr{regression.500.3[66, 1]} \; (\Sexpr{regression.500.3[66, 2]})$ & 
  $\Sexpr{regression.500.3[97, 1]} \; (\Sexpr{regression.500.3[97, 2]})$ & 
  $\Sexpr{regression.500.3[128, 1]} \; (\Sexpr{regression.500.3[128, 2]})$ \\
    & area & 
  $\Sexpr{regression.500.3[30, 1]} \; (\Sexpr{regression.500.3[30, 2]})$ & 
  $\Sexpr{regression.500.3[61, 1]} \; (\Sexpr{regression.500.3[61, 2]})$ & 
  $\Sexpr{regression.500.3[92, 1]} \; (\Sexpr{regression.500.3[92, 2]})$ & 
  $\Sexpr{regression.500.3[123, 1]} \; (\Sexpr{regression.500.3[123, 2]})$ & 
  $\Sexpr{regression.500.3[154, 1]} \; (\Sexpr{regression.500.3[154, 2]})$ \\
    & prediction error & 
  $\Sexpr{regression.500.3[31, 1]} \; (\Sexpr{regression.500.3[31, 2]})$ & 
  $\Sexpr{regression.500.3[62, 1]} \; (\Sexpr{regression.500.3[62, 2]})$ & 
  $\Sexpr{regression.500.3[93, 1]} \; (\Sexpr{regression.500.3[93, 2]})$ & 
  $\Sexpr{regression.500.3[124, 1]} \; (\Sexpr{regression.500.3[124, 2]})$ & 
  $\Sexpr{regression.500.3[155, 1]} \; (\Sexpr{regression.500.3[155, 2]})$ 
\end{tabular}
\end{center}
\caption{Diagnostics for conformal prediction regions for linear regression 
  models with normal errors and constant variance.  Local and marginal 
  coverage properties, areas, and prediction errors are presented for the 
    parametric conformal prediction region (third column),
    nonparametric conformal prediction region (fourth column),
    LS conformal prediction region (fifth column), 
    LSLW conformal prediction region (sixth column), and 
    HD prediction region (seventh column). Standard errors are in parentheses.}
\label{Tab:regression-results}
\end{table}





\newpage
\begin{figure}[h!]
\begin{center}
<<Fig-regression-inx-500, echo = FALSE, fig.height = 3>>=
par(mfrow = c(1,3), oma = c(4,4,1,0), mar = c(1,3,3,0))

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.60, 1.00))
lines(inx, regression.150.2[4:28, 1], col = "red", lty = 1, lwd = 1.5)
lines(inx, regression.150.2[34:58, 1], col = "green", lty = 2, lwd = 1.5)
lines(inx, regression.150.2[64:88, 1], col = "purple", lty = 1, lwd = 1.5)
lines(inx, regression.150.2[94:118, 1], col = "black", lty = 2, lwd = 1.5)
lines(inx, regression.150.2[124:148, 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1); axis(2)
mtext("n = 150", side = 3, cex = 1, line = 2)

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.60, 1.00))
lines(inx, regression.250.3[5:29, 1], col = "red", lty = 1, lwd = 1.5)
lines(inx, regression.250.3[36:60, 1], col = "green", lty = 2, lwd = 1.5)
lines(inx, regression.250.3[67:91, 1], col = "purple", lty = 1, lwd = 1.5)
lines(inx, regression.250.3[98:122, 1], col = "black", lty = 2, lwd = 1.5)
lines(inx, regression.250.3[129:153, 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("n = 250", side = 3, cex = 1, line = 2)

#plot.new()
#plot.window(xlim = c(0, 1), ylim = c(0.60, 1.00))
legend(0.15, 0.85, legend=c("parametric", 
  "nonparametric", "LSLW", "LS", "HD", "nominal coverage"), 
  col=c("red", "green", "purple", "black", "blue", "grey"), cex = 1,
  lty=c(1,2,1,2,4,1), bty = "n")

plot.new()
plot.window(xlim = c(0, 1), ylim = c(0.60, 1.00))
lines(inx, regression.500.3[5:29, 1], col = "red", lty = 1, lwd = 1.5)
lines(inx, regression.500.3[36:60, 1], col = "green", lty = 2, lwd = 1.5)
lines(inx, regression.500.3[67:91, 1], col = "purple", lty = 1, lwd = 1.5)
lines(inx, regression.500.3[98:122, 1], col = "black", lty = 2, lwd = 1.5)
lines(inx, regression.500.3[129:153, 1], col = "blue", lty = 4, lwd = 1.5)
abline(h = 0.90, lty = 1, col = "grey", lwd = 1.5)
axis(1)
mtext("n = 500", side = 3, cex = 1, line = 2)


mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("coverage", side = 2, cex = 1.25, line = 0, outer = TRUE)

@
\end{center}
\caption{Plot of the estimated coverage probabilities of prediction regions 
  across $x$ and sample sizes.}
\label{Fig:regresion.inx}
\end{figure}






\newpage
\section{Example plots of prediction regions}
\label{sec:plotsofregions}

In this section we construct prediction regions corresponding to the 
simulations and results in Sections~\ref{sec:Gamma} through 
\ref{sec:regressionplots}.  In Gamma analyses we generate a dataset for each 
shape parameter considered with $n = 150$ and in regression analyses we 
generate a dataset for all sample sizes considered.  For each of these datasets 
we depict the parametric, nonparametric, LS, LSLW conformal prediction regions 
over the observed data to visually assess the appropriateness of each 
prediction region.  The findings from these figures are consistent with the 
findings from our numerical diagnostics.  
The parametric conformal prediction region gives visually natural bounds for 
the observed data when the model is correctly specified in small to moderate 
sample sizes and is appropriate when the model is misspecified. 
The LSLW conformal prediction region gives visually natural bounds for the 
observed data when the model is correctly specified, is appropriate under mild 
model misspecification, and is ill-fitting in settings where deviations about 
an estimated mean function are clearly not symmetric.
The nonparametric conformal prediction region is coarse and is larger than 
necessary when the mean function is steep relative to its variability.  
The LS conformal prediction performs well when deviations about the estimated 
mean function are symmetirc and is sensitive to mild departures from that 
setting.  This prediciton region is seen to provide overcoverage 
(undercoverage) in regions of the predictor space where variability about the 
estimated mean function is relatively small (large).



\newpage
\begin{figure}[h!]
\begin{center}
<<conformal-plots, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(3, 4), oma = c(4,4,2,0), mar = c(1,1,1,1))

######### Sim setting A ####################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 150
bins <- 2
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate gamma regression model 
beta <- c(1.25, -1); shape = 1
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Parametric \n conformal", side = 3, cex = 1, line = 0)
mtext("Setting A", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW \n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("Nonparametric \n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS \n conformal", side = 3, cex = 1, line = 0)

######### Sim setting B ####################
## generate gamma regression model (misspecified parametric conformal)
beta <- c(0.5, 1); shape = 10
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Setting B", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)

######### Sim setting C ####################
## generate linear regression model
beta <- c(2, 5)
mu <- (cbind(1, x) %*% beta) 
y <- rnorm(n = n, mean = mu, sd = 1)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the regression model
fit <- glm(y ~ x1, family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
fit <- lm(y ~ x1, data = data)
abs.resid <- abs(fit$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1); axis(2)
mtext("Setting C", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 3, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions when $n = 150$ that 
  appears in \citet{eck2019conformal}.  The rows display conformal prediction 
  regions across simulation settings.  The columns display the different 
  conformal prediction regions.  The top, middle, and bottom rows correspond 
  to simulation setting a with shape parameter equal to 1, simulation setting 
  b with shape parameter equal to 10, and simulation setting c respectively.  
  The first column displays the parametric conformal prediction region which 
  is misspecified in row 2, the second column displays the least squares 
  locally weighted conformal prediction region, the third column displays the 
  nonparametric conformal prediction region, and the fourth column displays 
  the least squares conformal prediction region.}
\label{conformal-plots}
\end{figure}











\newpage
\subsection{Plots corresponding to Section~\ref{sec:Gamma}}
\label{sec:gammaplots}

%Plot of conformal prediciton regions in sim setting A when n = 150
\begin{figure}[h!]
\begin{center}
<<conformal-plots-A-150, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(4, 4), oma = c(4,4,2,0), mar = c(1,2,1,1))

############ shape = 0.75 ################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 150
bins <- 2
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate gamma regression model 
beta <- c(1.25, -1); shape = 0.75
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Parametric \n conformal", side = 3, cex = 1, line = 0)
mtext("shape = 0.75", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW\n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("nonparametric\n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS\n conformal", side = 3, cex = 1, line = 0)


############ shape = 2 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 2
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 2", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 10 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 10
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 50 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 50
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1);axis(2)
mtext("shape = 50", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 2, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions under simulation 
  setting A when $n = 150$ and the number of bins equals 2.
}
\label{conformal-plots-A-150}
\end{figure}











\newpage
%Plot of conformal prediciton regions in sim setting A when n = 250
\begin{figure}[h!]
\begin{center}
<<conformal-plots-A-250, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(4, 4), oma = c(4,4,2,0), mar = c(1,2,1,1))

############ shape = 0.75 ################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 250
bins <- 3
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate gamma regression model 
beta <- c(1.25, -1); shape = 0.75
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Parametric\n conformal", side = 3, cex = 1, line = 0)
mtext("shape = 0.75", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW\n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("Nonparametric\n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS\n conformal", side = 3, cex = 1, line = 0)


############ shape = 2 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 2
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 2", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 10 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 10
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 50 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 50
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1);axis(2)
mtext("shape = 50", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 2, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions under simulation 
  setting A when $n = 250$ and the number of bins equals 3.
}
\label{conformal-plots-A-250}
\end{figure}








\newpage
%Plot of conformal prediciton regions in sim setting A when n = 500
\begin{figure}[h!]
\begin{center}
<<conformal-plots-A-500, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(4, 4), oma = c(4,4,2,0), mar = c(1,2,1,1))

############ shape = 0.75 ################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 500
bins <- 3
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate gamma regression model 
beta <- c(1.25, -1); shape = 0.75
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Parametric\n conformal", side = 3, cex = 1, line = 0)
mtext("shape = 0.75", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW\n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("Nonparametric\n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS\n conformal", side = 3, cex = 1, line = 0)


############ shape = 2 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 2
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 2", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 10 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 10
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 50 ################
## generate gamma regression model 
beta <- c(1.25, -1); shape = 50
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the Gamma regression model
fit <- glm(y ~ x1, family = "Gamma", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1);axis(2)
mtext("shape = 50", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 2, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions under simulation 
  setting A when $n = 500$ and the number of bins equals 3.
}
\label{conformal-plots-A-500}
\end{figure}







\newpage
\subsection{Plots corresponding to Section~\ref{sec:misspec}}
\label{sec:misspecplots}


%Plot of conformal prediciton regions in sim setting B when n = 150
\begin{figure}[h!]
\begin{center}
<<conformal-plots-B-150, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(4, 4), oma = c(4,4,2,0), mar = c(1,2,1,1))

############ shape = 0.75 ################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 150
bins <- 2
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate gamma regression model 
beta <- c(0.5, 1); shape = 0.75
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Parametric\n conformal", side = 3, cex = 1, line = 0)
mtext("shape = 0.75", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW\n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("Nonparametric\n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS\n conformal", side = 3, cex = 1, line = 0)


############ shape = 2 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 2
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 2", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 10 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 10
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 50 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 50
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1);axis(2)
mtext("shape = 50", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 2, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions under simulation 
  setting B when $n = 150$ and the number of bins equals 2.
}
\label{conformal-plots-B-150}
\end{figure}










\newpage
%Plot of conformal prediciton regions in sim setting B when n = 250
\begin{figure}[h!]
\begin{center}
<<conformal-plots-B-250, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(4, 4), oma = c(4,4,2,0), mar = c(1,2,1,1))

############ shape = 0.75 ################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 250
bins <- 3
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate gamma regression model 
beta <- c(0.5, 1); shape = 0.75
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Parametric\n conformal", side = 3, cex = 1, line = 0)
mtext("shape = 0.75", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW\n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("Nonparametric\n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS\n conformal", side = 3, cex = 1, line = 0)


############ shape = 2 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 2
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 2", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 10 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 10
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 50 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 50
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1);axis(2)
mtext("shape = 50", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 2, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions under simulation 
  setting B when $n = 250$ and the number of bins equals 3.
}
\label{conformal-plots-B-250}
\end{figure}









\newpage
%Plot of conformal prediciton regions in sim setting B when n = 500
\begin{figure}[h!]
\begin{center}
<<conformal-plots-B-500, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(4, 4), oma = c(4,4,2,0), mar = c(1,2,1,1))

############ shape = 0.75 ################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 500
bins <- 3
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate gamma regression model 
beta <- c(0.5, 1); shape = 0.75
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("Parametric\n conformal", side = 3, cex = 1, line = 0)
mtext("shape = 0.75", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW\n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("Nonparametric\n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS\n conformal", side = 3, cex = 1, line = 0)


############ shape = 2 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 2
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 2", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 10 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 10
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("shape = 10", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0,1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


############ shape = 50 ################
## generate gamma regression model 
beta <- c(0.5, 1); shape = 50
rate <- (cbind(1, x) %*% beta) * shape
y <- rgamma(n = n, shape = shape, rate = rate)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the misspecified regression model
fit <- glm(y ~ x1 + I(x1^2) + I(x1^3), 
  family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = cbind(x, x^2, x^3), y = y, 
  x0 = cbind(x, x^2, x^3), train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
cubic.model <- lm(y ~ x + I(x^2) + I(x^3))
abs.resid <- abs(cubic.model$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = cbind(x,x^2,x^3), y = y, 
  x0 = cbind(x,x^2,x^3), 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1);axis(2)
mtext("shape = 50", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 2, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions under simulation 
  setting B when $n = 500$ and the number of bins equals 3.
}
\label{conformal-plots-B-500}
\end{figure}









\newpage
\subsection{Plots corresponding to Section~\ref{sec:regression}}
\label{sec:regressionplots}

%Plot of conformal prediciton regions in sim setting C
\begin{figure}[h!]
\begin{center}
<<conformal-plots-C, fig.height = 7, cache = TRUE, echo = FALSE>>=
par(mfrow = c(3, 4), oma = c(4,4,2,0), mar = c(1,2,1,1))

######### n = 150 ####################
## generate random data
set.seed(13)
alpha <- 0.10
cores <- 6
n <- 150
bins <- 2
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate linear regression model
beta <- c(2, 5)
mu <- (cbind(1, x) %*% beta) 
y <- rnorm(n = n, mean = mu, sd = 1)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the regression model
fit <- glm(y ~ x1, family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
fit <- lm(y ~ x1, data = data)
abs.resid <- abs(fit$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("n = 150", side = 2, cex = 1, line = 2)
mtext("Parametric\n conformal", side = 3, cex = 1, line = 0)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
mtext("LSLW\n conformal", side = 3, cex = 1, line = 0)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
mtext("Nonparametric\n conformal", side = 3, cex = 1, line = 0)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
mtext("LS\n conformal", side = 3, cex = 1, line = 0)


######### n = 250 ####################
## generate random data
n <- 250
bins <- 3
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate linear regression model
beta <- c(2, 5)
mu <- (cbind(1, x) %*% beta) 
y <- rnorm(n = n, mean = mu, sd = 1)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the regression model
fit <- glm(y ~ x1, family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
fit <- lm(y ~ x1, data = data)
abs.resid <- abs(fit$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(2)
mtext("n = 250", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)


######### n = 500 ####################
## generate random data
n <- 500
bins <- 3
p <- k <- length(beta) - 1
x <- matrix(runif(n), ncol = p)

## generate linear regression model
beta <- c(2, 5)
mu <- (cbind(1, x) %*% beta) 
y <- rnorm(n = n, mean = mu, sd = 1)
y <- y / sd(y)
data <- data.frame(y = y, x = x)
colnames(data)[2:(p+1)] <- paste("x", 1:p, sep = "")

## fit the regression model
fit <- glm(y ~ x1, family = "gaussian", data = data)
formula <- fit$formula
newdata <- data
respname <- all.vars(formula)[1]
newdata <- newdata[, !(colnames(data) %in% respname)]
newdata <- as.matrix(newdata)

## obtain parametric and nonparametric conformal 
## prediction regions
cpred <- conformal.glm(fit, parametric = TRUE, 
  nonparametric = FALSE, alpha = alpha,
  bins = bins, cores = cores)
paraCI <- cpred$paraconformal

cpred <- conformal.glm(fit, parametric = FALSE, 
  nonparametric = TRUE, alpha = alpha,
  bins = bins, cores = cores)
nonparaCI <- cpred$nonparaconformal

## obtain LS conformal prediction region
p1.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, 
  predict.fun = predict.fun, alpha = alpha, 
  grid.method = "linear")
LSCI <- cbind(p1.tibs$lo, p1.tibs$up)

## obtain LSLW conformal prediction region
fit <- lm(y ~ x1, data = data)
abs.resid <- abs(fit$resid)
smooth.call <- smooth.spline(x, abs.resid, 
  nknots = 10)
lambda <- smooth.call$lambda
df <- smooth.call$df
mad.train.fun <- function(x, y, out = NULL){
  smooth.spline(x[, 1], y, lambda = lambda, 
  df = df, nknots = 10)
}
p2.tibs <- conformal.pred(x = x, y = y, x0 = x, 
  train.fun = train.fun, predict.fun = predict.fun, 
  mad.train.fun = mad.train.fun,
  mad.predict.fun = mad.predict.fun,
  alpha = alpha)
LSLWCI <- cbind(p2.tibs$lo, p2.tibs$up)  

## create plots
ix <- sort(x, index.return = TRUE)$ix

## parametric conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], paraCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], paraCI[ix, 2], col = "red", lwd = 1.5)
axis(1); axis(2)
mtext("n = 500", side = 2, cex = 1, line = 2)

## LSLW conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSLWCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSLWCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

## nonparametric conformal
plot.nonparametric(region = nonparaCI, x = x, 
  y = y, bins = bins)
axis(1)

## LS conformal
plot.new()
plot.window(xlim = c(0, 1), ylim = c(min(y)-1, max(y)+1))
points(x, y, pch = 19, col = rgb(0,0,0,alpha=0.2))
lines(x[ix], LSCI[ix, 1], col = "red", lwd = 1.5)
lines(x[ix], LSCI[ix, 2], col = "red", lwd = 1.5)
axis(1)

mtext("x", side = 1, cex = 1, line = 2, outer = TRUE)
mtext("y", side = 2, cex = 1, line = 2, outer = TRUE)
@
\end{center}
\caption{The depiction of conformal prediction regions under simulation 
  setting C.
}
\label{conformal-plots-C}
\end{figure}


















\section{Creating this Document}
The purpose of this document is to provide a completely reproducible 
exploration and motivation of conformal prediction. All of the R code 
presented in this document (or the corresponding .Rnw file) is run when 
this document is compiled using the linux terminal.

This document is created from its source file 
\texttt{supplement-conformal.Rnw} using \texttt{knitr} and the 
\texttt{pdflatex} command in the linux terminal. The \texttt{knitr} R package 
needs to be installed before this document can be compiled. Open R and install 
this package if you have not previously done so. To compile this document in 
the linux terminal, enter the command 
\vspace{0.25cm}\\
\texttt{Rscript -e "library(knitr); knit('supplement-conformal.Rnw')"} 
\vspace{0.25cm}\\
This produces the LaTex .tex file with the name 
\texttt{supplement-conformal.tex}. To get a corresponding .pdf file, enter 
the command
\vspace{0.25cm}\\
\texttt{pdflatex supplement-conformal.tex} 
\vspace{0.25cm}\\
You may want to run the previous command twice in order to get labels and 
references right.

\bibliographystyle{plainnat}

\bibliography{conformalsources}

\end{document}

